[{"/Users/richardmcgirt/Desktop/Warrenty2-/src/index.js":"1","/Users/richardmcgirt/Desktop/Warrenty2-/src/reportWebVitals.js":"2","/Users/richardmcgirt/Desktop/Warrenty2-/src/App.js":"3"},{"size":1042,"mtime":1723728469192,"results":"4","hashOfConfig":"5"},{"size":362,"mtime":1723726139777,"results":"6","hashOfConfig":"5"},{"size":19073,"mtime":1724857311394,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","suppressedMessages":"10","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"11"},"1bozzpw",{"filePath":"12","messages":"13","suppressedMessages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"11"},{"filePath":"15","messages":"16","suppressedMessages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18"},"/Users/richardmcgirt/Desktop/Warrenty2-/src/index.js",[],[],[],"/Users/richardmcgirt/Desktop/Warrenty2-/src/reportWebVitals.js",[],[],"/Users/richardmcgirt/Desktop/Warrenty2-/src/App.js",["19"],[],"import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { useSession, useSupabaseClient, useSessionContext } from '@supabase/auth-helpers-react';\n\n// Debounce function to avoid rapid API calls\nfunction debounce(func, wait) {\n  let timeout;\n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// Fetch added records from Airtable\nasync function fetchAddedRecordsFromAirtable() {\n  try {\n    const response = await fetch('https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ', {\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238'\n      }\n    });\n\n    const data = await response.json();\n    return data.records\n      .filter(record => record.fields['Status'] === 'Added')\n      .map(record => record.fields['YourRecordFieldName']);\n  } catch (error) {\n    console.error('Error fetching added records from Airtable:', error);\n    return [];\n  }\n}\n\n// Fetch failed records from Airtable\nasync function fetchFailedRecordsFromAirtable() {\n  try {\n    const response = await fetch('https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ', {\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238'\n      }\n    });\n\n    const data = await response.json();\n    return data.records\n      .filter(record => record.fields['Status'] === 'Failed')\n      .map(record => record.fields['YourRecordFieldName']);\n  } catch (error) {\n    console.error('Error fetching failed records from Airtable:', error);\n    return [];\n  }\n}\n\n// Helper function to get a greeting based on the time of day\nfunction getGreeting() {\n  const currentHour = new Date().getHours();\n  if (currentHour < 12) {\n    return \"Good morning\";\n  } else if (currentHour < 18) {\n    return \"Good afternoon\";\n  } else {\n    return \"Good evening\";\n  }\n}\n\n// Function to create a Google Calendar event\nasync function createGoogleCalendarEvent(event, calendarId, session, signOut, setRateLimitInfo) {\n  console.log('Attempting to create a new Google Calendar event:', event);\n\n  if (!session.provider_token) {\n    console.error('No valid session token available. Logging out.');\n    signOut();\n    return null;\n  }\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n\n  const pictureUrlsDescription = event.pictureUrls.length > 0 \n    ? 'Pictures of Issue:\\n' + event.pictureUrls.join('\\n')\n    : 'No pictures provided.';\n\n  const newEvent = {\n    summary: event.title,\n    description: `\n      ${event.description ? event.description + '\\n' : ''}\n      Homeowner Name: ${event.homeownerName}\n      Lot Number: ${event.lotNumber}\n      Community/Neighborhood: ${event.community}\n      Contact Email: ${event.contactEmail}\n      Calendar Link: ${event.calendarLink ? event.calendarLink : 'Not Provided'}\n      ${pictureUrlsDescription}\n    `,\n    start: { dateTime: event.start.toISOString() },\n    end: { dateTime: event.end.toISOString() },\n    location: `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}`,\n  };\n\n  console.log('New event data:', newEvent);\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Authorization': 'Bearer ' + session.provider_token,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(newEvent)\n    });\n\n    // Capture rate limit info from headers\n    const remaining = response.headers.get('X-RateLimit-Remaining');\n    const limit = response.headers.get('X-RateLimit-Limit');\n    const reset = response.headers.get('X-RateLimit-Reset');\n    setRateLimitInfo({ remaining, limit, reset });\n\n    const data = await response.json();\n    console.log('Google Calendar creation response:', data);\n    if (data.error) {\n      console.error('Error creating event:', data.error);\n      if (data.error.code === 401) {\n        console.error('Unauthorized - Logging out');\n        signOut(); // Logout if unauthorized\n      }\n      return null;\n    } else {\n      console.log('New event successfully created:', data);\n      return data.id;\n    }\n  } catch (error) {\n    console.error('Error during fetch request:', error);\n    return null;\n  }\n}\n\n// Function to update Airtable with the Google Event ID\nasync function updateAirtableWithGoogleEventId(airtableRecordId, googleEventId) {\n  console.log('Updating Airtable with new Google Event ID:', googleEventId);\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  const updateData = {\n    fields: {\n      GoogleEventId: googleEventId\n    }\n  };\n\n  console.log('Airtable update data:', updateData);\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(updateData)\n    });\n\n    const data = await response.json();\n    console.log('Airtable API response for update:', data);\n    if (data.error) {\n      console.error('Error updating Airtable with Google Event ID:', data.error);\n    } else {\n      console.log('Airtable record successfully updated:', data);\n    }\n  } catch (error) {\n    console.error('Error during fetch request:', error);\n  }\n}\n\n// Fetch events from Airtable\nasync function fetchAirtableEvents(retryCount = 0) {\n  console.log('Fetching events from Airtable');\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ`;\n  const maxRetries = 1;\n\n  try {\n    const response = await fetch(url, {\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json'\n      }\n    });\n\n    if (!response.ok) {\n      if (response.status === 429) {\n        const retryAfter = response.headers.get('Retry-After');\n        const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, retryCount) * 1000;\n\n        console.warn(`Rate limit hit. Retrying after ${waitTime}ms...`);\n\n        if (retryCount < maxRetries) {\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n          return fetchAirtableEvents(retryCount + 1);\n        } else {\n          throw new Error('Max retries exceeded');\n        }\n      } else {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n    }\n\n    const data = await response.json();\n    console.log('Fetched data from Airtable:', data);\n\n    return data.records\n      .filter(record => record.fields['Calendar Event Name'] && record.fields['startDate'] && record.fields['endDate'])\n      .map(record => ({\n        id: record.id,\n        title: record.fields['Calendar Event Name'] || \"Untitled Event\",\n        start: new Date(record.fields['startDate']),\n        end: new Date(record.fields['endDate']),\n        description: record.fields['Billable Reason (If Billable)'] || '',\n        branch: record.fields['b'] || 'Unknown',\n        homeownerName: record.fields['Homeowner Name'] || 'Unknown',\n        lotNumber: record.fields['Lot Number'] || 'Unknown',\n        community: record.fields['Community/Neighborhood'] || 'Unknown',\n        contactEmail: record.fields['Contact Email'] || 'Unknown',\n        calendarLink: record.fields['Calendar Link'] || '',\n        pictureUrls: record.fields['Picture(s) of Issue']?.map(pic => pic.url) || [],\n        streetAddress: record.fields['Street Address'] || 'Unknown',\n        city: record.fields['City'] || 'Unknown',\n        state: record.fields['State'] || 'Unknown',\n        zipCode: record.fields['Zip Code'] || 'Unknown',\n        googleEventId: record.fields['GoogleEventId'] || null,\n      }));\n\n  } catch (error) {\n    console.error('Error fetching events from Airtable:', error);\n\n    if (retryCount < maxRetries) {\n      console.log(`Retrying fetch attempt ${retryCount + 1} of ${maxRetries}...`);\n      return fetchAirtableEvents(retryCount + 1);\n    } else {\n      throw error;\n    }\n  }\n}\n\n// Function to check for duplicate events in Google Calendar\nasync function checkForDuplicateEvent(event, calendarId, session) {\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${event.start.toISOString()}&timeMax=${event.end.toISOString()}`;\n\n  const response = await fetch(url, {\n    headers: {\n      'Authorization': 'Bearer ' + session.provider_token,\n    },\n  });\n\n  const data = await response.json();\n\n  if (data.items) {\n    return data.items.some(existingEvent =>\n      existingEvent.summary === event.title &&\n      existingEvent.location === `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}`\n    );\n  }\n\n  return false;\n}\n\n// Function to introduce a delay\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Function to populate Google Calendar with records from Airtable\nasync function populateGoogleCalendarWithAirtableRecords(calendarId, calendarName, session, signOut, setAddedRecords, setFailedRecords, setRateLimitInfo) {\n  console.log(`Populating Google Calendar (${calendarName}) with Airtable records...`);\n\n  const airtableEvents = await fetchAirtableEvents();\n  const added = [];\n  const failed = [];\n\n  for (const event of airtableEvents) {\n    // Skip events where the branch is \"Unknown\" or does not match the calendar name\n    if (event.branch.toLowerCase() === 'unknown' || event.branch.toLowerCase() !== calendarName.toLowerCase()) {\n      console.log(`Skipping event \"${event.title}\" due to branch \"${event.branch}\" not matching \"${calendarName}\" or being \"Unknown\"`);\n      continue;\n    }\n\n    if (event.googleEventId) {\n      console.log(`Skipping already synced event: ${event.title}`);\n      continue;\n    }\n\n    const isDuplicate = await checkForDuplicateEvent(event, calendarId, session);\n    if (isDuplicate) {\n      console.log(`Duplicate event found: \"${event.title}\". Skipping...`);\n      failed.push(event.title);\n      continue;\n    }\n\n    const googleEventId = await createGoogleCalendarEvent(event, calendarId, session, signOut, setRateLimitInfo);\n    if (googleEventId) {\n      console.log('New Google Event ID created:', googleEventId);\n      await updateAirtableWithGoogleEventId(event.id, googleEventId);\n      added.push(event.title);\n    } else {\n      failed.push(event.title);\n    }\n\n    // Introduce a delay of 1 second between requests\n    await sleep(1000);\n  }\n\n  setAddedRecords(prev => [...prev, ...added]);\n  setFailedRecords(prev => [...prev, ...failed]);\n\n  console.log(`Finished populating Google Calendar (${calendarName}) with Airtable records.`);\n}\n\n// Component to display each calendar section with countdown\nfunction CalendarSection({ calendarId, calendarName, session, signOut, setAddedRecords, setFailedRecords, setRateLimitInfo }) {\n  const [lastSyncTime, setLastSyncTime] = useState(null);\n  const [timeUntilNextSync, setTimeUntilNextSync] = useState(0);\n\n  useEffect(() => {\n    const calculateTimeUntilNextSync = () => {\n      const now = new Date();\n      if (lastSyncTime) {\n        const elapsed = now - lastSyncTime;\n        const remainingTime = 450000 - elapsed; // 450,000 ms = 7.5 minutes\n        setTimeUntilNextSync(Math.max(0, remainingTime));\n      }\n    };\n\n    const syncEvents = () => {\n      const now = new Date();\n\n      // Calculate time since last sync\n      if (lastSyncTime && (now - lastSyncTime) < 450000) {\n        calculateTimeUntilNextSync();\n        return;\n      }\n\n      if (session) {\n        if (!session.provider_token) {\n          console.error('No valid session token found. Logging out.');\n          signOut();\n          return;\n        }\n\n        populateGoogleCalendarWithAirtableRecords(\n          calendarId, \n          calendarName, \n          session, \n          signOut, \n          setAddedRecords, \n          setFailedRecords, \n          setRateLimitInfo\n        )\n          .then(() => {\n            console.log(`Finished syncing Airtable events to Google Calendar (${calendarName})`);\n            setLastSyncTime(new Date());  // Update last sync time\n            setTimeUntilNextSync(450000);  // Reset countdown\n          })\n          .catch(error => console.error(`Error syncing Airtable to Google Calendar (${calendarName}):`, error));\n      }\n    };\n\n    // Run syncEvents immediately when the component mounts\n    syncEvents();\n\n    // Set up an interval to run syncEvents every 6.6 minutes (400000 ms)\n    const intervalId = setInterval(syncEvents, 400000);\n\n    // Update countdown every second\n    const countdownInterval = setInterval(() => {\n      calculateTimeUntilNextSync();\n    }, 1000);\n\n    // Clear the intervals when the component unmounts\n    return () => {\n      clearInterval(intervalId);\n      clearInterval(countdownInterval);\n    };\n  }, [session, signOut, calendarId, calendarName, setAddedRecords, setFailedRecords, setRateLimitInfo, lastSyncTime]);\n\n  // Convert milliseconds to mm:ss format\n  const formatTime = (ms) => {\n    const totalSeconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n    return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;\n  };\n\n  return (\n    <div className=\"calendar-item\">\n      <h2>{calendarName}</h2>\n      {timeUntilNextSync > 0 ? (\n        <p>Next sync available in: {formatTime(timeUntilNextSync)}</p>\n      ) : (\n        <p>Ready to sync!</p>\n      )}\n    </div>\n  );\n}\n\n// Main App component\nfunction App() {\n  const session = useSession();\n  const supabase = useSupabaseClient();\n  const { isLoading } = useSessionContext();\n\n  const [addedRecords, setAddedRecords] = useState([]);\n  const [failedRecords, setFailedRecords] = useState([]);\n  const [rateLimitInfo, setRateLimitInfo] = useState({ remaining: null, limit: null, reset: null });\n\n  useEffect(() => {\n    // Fetch existing records from Airtable or another source if needed\n    async function fetchExistingRecords() {\n      const existingAddedRecords = await fetchAddedRecordsFromAirtable();\n      const existingFailedRecords = await fetchFailedRecordsFromAirtable();\n\n      setAddedRecords(existingAddedRecords);\n      setFailedRecords(existingFailedRecords);\n    }\n\n    fetchExistingRecords();\n  }, []);\n\n  const calendarInfo = [\n    { id: 'c_d113e252e0e5c8cfbf17a13149707a30d3c0fbeeff1baaac7a46940c2cc448ca@group.calendar.google.com', name: 'Charleston' },\n    { id: 'c_03867438b82e5dfd8d4d3b6096c8eb1c715425fa012054cc95f8dea7ef41c79b@group.calendar.google.com', name: 'Greensboro' },\n    { id: 'c_ad562073f4db2c47279af5aa40e53fc2641b12ad2497ccd925feb220a0f1abee@group.calendar.google.com', name: 'Myrtle Beach' },\n    { id: 'c_45db4e963c3363676038697855d7aacfd1075da441f9308e44714768d4a4f8de@group.calendar.google.com', name: 'Wilmington' },\n    { id: 'https://calendar.google.com/calendar/embed?src=c_0476130ac741b9c58b404c737a8068a8b1b06ba1de2a84cff08c5d15ced54edf%40group.calendar.google.com&ctz=America%2FToronto', name: 'Grenville'},\n    { id: 'https://calendar.google.com/calendar/embed?src=c_df033dd6c81bb3cbb5c6fdfd58dd2931e145e061b8a04ea0c13c79963cb6d515%40group.calendar.google.com&ctz=America%2FToronto', name: 'Columbia'},\n    { id: 'warranty@vanirinstalledsales.com', name: 'Raleigh' }\n  ].sort((a, b) => a.name.localeCompare(b.name));\n\n  const handleManualSync = async () => {\n    if (!session) return;\n\n    for (const calendar of calendarInfo) {\n      await populateGoogleCalendarWithAirtableRecords(\n        calendar.id,\n        calendar.name,\n        session,\n        () => supabase.auth.signOut(),\n        setAddedRecords,\n        setFailedRecords,\n        setRateLimitInfo\n      );\n    }\n  };\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div className=\"App\">\n      <div className=\"container\">\n        <h1>Warranty Calendar</h1>\n        <div style={{ width: \"100%\", margin: \"0 auto\" }}>\n          {session ?\n            <>\n              <h2>{getGreeting()} {session.user.email}</h2>\n              <hr />\n              <div className=\"calendar-grid\">\n                {calendarInfo.map(calendar => (\n                  <CalendarSection\n                    key={calendar.id}\n                    calendarId={calendar.id}\n                    calendarName={calendar.name}\n                    session={session}\n                    signOut={() => supabase.auth.signOut()}\n                    setAddedRecords={setAddedRecords}\n                    setFailedRecords={setFailedRecords}\n                    setRateLimitInfo={setRateLimitInfo}\n                  />\n                ))}\n              </div>\n              <div className=\"records-summary\">\n                <h3>Records Summary</h3>\n                <div className=\"summary-container\">\n                  <div className=\"added-records\">\n                    <h4>Successfully Added Records:</h4>\n                    {addedRecords.length > 0 ? (\n                      <ul>\n                        {addedRecords.map((record, index) => (\n                          <li key={index}>{record}</li>\n                        ))}\n                      </ul>\n                    ) : (\n                      <p>No records added.</p>\n                    )}\n                  </div>\n                  <div className=\"failed-records\">\n                    <h4>Failed to Add Records:</h4>\n                    {failedRecords.length > 0 ? (\n                      <ul>\n                        {failedRecords.map((record, index) => (\n                          <li key={index}>{record}</li>\n                        ))}\n                      </ul>\n                    ) : (\n                      <p>No records failed.</p>\n                    )}\n                  </div>\n                </div>\n              </div>\n              <div className=\"rate-limit-info\">\n                <h4>Google Calendar API Rate Limit Information:</h4>\n                {rateLimitInfo.limit !== null ? (\n                  <ul>\n                    <li>Limit: {rateLimitInfo.limit}</li>\n                    <li>Remaining: {rateLimitInfo.remaining}</li>\n                    <li>Reset Time: {new Date(rateLimitInfo.reset * 1000).toLocaleTimeString()}</li>\n                  </ul>\n                ) : (\n                  <p>No rate limit information available.</p>\n                )}\n              </div>\n              <button onClick={handleManualSync}>Sync Data Now</button>\n              <p></p>\n              <button onClick={() => supabase.auth.signOut()}>Sign Out</button>\n            </>\n            :\n            <>\n              <button onClick={() => supabase.auth.signInWithOAuth({ provider: 'google', options: { scopes: 'https://www.googleapis.com/auth/calendar' } })}>\n                Sign In With Google\n              </button>\n            </>\n          }\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",{"ruleId":"20","severity":1,"message":"21","line":6,"column":10,"nodeType":"22","messageId":"23","endLine":6,"endColumn":18},"no-unused-vars","'debounce' is defined but never used.","Identifier","unusedVar"]