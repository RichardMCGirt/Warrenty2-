[{"/Users/richardmcgirt/Desktop/Warrenty2-/src/index.js":"1","/Users/richardmcgirt/Desktop/Warrenty2-/src/reportWebVitals.js":"2","/Users/richardmcgirt/Desktop/Warrenty2-/src/App.js":"3"},{"size":1042,"mtime":1723728469192,"results":"4","hashOfConfig":"5"},{"size":362,"mtime":1723726139777,"results":"6","hashOfConfig":"5"},{"size":20597,"mtime":1726489769179,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","suppressedMessages":"10","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"11"},"11jqpoc",{"filePath":"12","messages":"13","suppressedMessages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"11"},{"filePath":"15","messages":"16","suppressedMessages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18"},"/Users/richardmcgirt/Desktop/Warrenty2-/src/index.js",[],[],[],"/Users/richardmcgirt/Desktop/Warrenty2-/src/reportWebVitals.js",[],[],"/Users/richardmcgirt/Desktop/Warrenty2-/src/App.js",["19","20"],[],"import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { useSession, useSupabaseClient, useSessionContext } from '@supabase/auth-helpers-react';\n\n\n\nasync function createGoogleCalendarEvent(event, calendarId, session, signOut, setRateLimitInfo, setRateLimitHit) {\n  console.log(`Attempting to create a new Google Calendar event for calendar: ${calendarId}`, event);\n\n  // Final duplicate check before creating\n  const existingGoogleEventId = await checkForDuplicateEvent(event, calendarId, session);\n  if (existingGoogleEventId) {\n    console.log('Duplicate event detected in final check, skipping creation:', existingGoogleEventId);\n    return existingGoogleEventId;\n  }\n\n  // Proceed with event creation\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n\n  const updatedEvent = {\n    summary: event.title,\n    description: `\n      ${event.description}\n      \\nlocation: ${event.location}\n      \\nHomeowner Name: ${event.homeownerName}\n      \\nMaterials Needed: ${event.materialsNeeded || 'Not specified'}\n    `,\n    start: { dateTime: event.start.toISOString() },\n    end: { dateTime: event.end.toISOString() },\n    location: `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}`,\n  };\n\n  console.log('Event data being sent to Google Calendar API:', updatedEvent);\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        Authorization: 'Bearer ' + session.provider_token,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updatedEvent),\n    });\n\n    if (response.status === 429) {\n      console.error('Rate limit reached. Stopping further requests.');\n      setRateLimitHit(true);\n      return null;\n    }\n\n    const data = await response.json();\n    if (response.ok) {\n      console.log('Event successfully created in Google Calendar with ID:', data.id);\n\n      // Update Airtable with the Google Event ID\n      await updateAirtableWithGoogleEventIdAndProcessed(event.id, data.id);\n\n      return data.id;\n    } else {\n      console.error('Failed to create event:', data);\n      return null;\n    }\n  } catch (error) {\n    console.error('Error during Google Calendar API request:', error);\n    return null;\n  }\n}\n\n\nasync function updateGoogleCalendarEvent(\n  event,\n  calendarId,\n  eventId,\n  session,\n  signOut,\n  setRateLimitInfo = () => {}, // Default empty function\n  setRateLimitHit = () => {} // Default empty function\n) {\n  console.log(`Updating Google Calendar event for ID: ${eventId}`);\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n\n  const updatedEvent = {\n    summary: event.title,\n    description: `\n      ${event.description}\n      \\nlocation: ${event.location}\n      \\nHomeowner Name: ${event.homeownerName}\n      \\nMaterials Needed: ${event.materialsNeeded || 'Not specified'}\n    `,\n    start: { dateTime: event.start.toISOString() },\n    end: { dateTime: event.end.toISOString() },\n    location: `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}`,\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer ' + session.provider_token,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updatedEvent),\n    });\n\n    // Check for rate limit and handle it\n    if (response.status === 429) {\n      console.error('Rate limit reached. Stopping further requests.');\n      setRateLimitHit(true); // Stop further requests\n      return null;\n    }\n\n    const data = await response.json();\n    const remaining = response.headers.get('X-RateLimit-Remaining');\n    const limit = response.headers.get('X-RateLimit-Limit');\n    const reset = response.headers.get('X-RateLimit-Reset');\n    setRateLimitInfo({ remaining, limit, reset });\n\n    if (response.ok) {\n      console.log('Event successfully updated in Google Calendar with ID:', data.id);\n      return data.id;\n    } else {\n      console.error('Failed to update event:', data);\n      if (data.error && data.error.code === 401) {\n        signOut(); // Handle invalid token by signing out\n      }\n      return null;\n    }\n  } catch (error) {\n    console.error('Error during Google Calendar API request in updateGoogleCalendarEvent:', error);\n    return null;\n  }\n}\n\n\n\n\nasync function updateAirtableWithGoogleEventIdAndProcessed(airtableRecordId, googleEventId) {\n  console.log(`Updating Airtable record ${airtableRecordId} with Google Event ID: ${googleEventId} and marking as processed`);\n  \n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n\n  // Ensure data matches Airtable fields exactly\n  const updateData = {\n    fields: {\n      GoogleEventId: googleEventId,  // Ensure this matches the Airtable field name exactly\n      Processed: true,               // Ensure this is a boolean if Airtable expects a checkbox\n      LastUpdated: new Date().toISOString(),  // Ensure this is in proper date format\n    },\n  };\n\n  console.log('Data being sent to Airtable:', updateData);  // Debug the data being sent\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',  // Replace with your actual API key\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    const data = await response.json();\nif (!response.ok) {\n  console.error('Error updating Airtable:', data.error);  // Inspect the error\n} else {\n      console.log('Airtable record successfully updated:', data);\n    }\n  } catch (error) {\n    console.error('Error during Airtable API request:', error);\n  }\n}\n\n\n\nasync function lockAirtableRecord(airtableRecordId) {\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  const updateData = {\n    fields: {\n      Processing: true, // Mark record as being processed\n    },\n  };\n\n  try {\n    await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n    console.log(`Locked record ${airtableRecordId} for Processed`);\n  } catch (error) {\n    console.error(`Failed to lock record ${airtableRecordId}`, error);\n  }\n}\n\nasync function unlockAirtableRecord(airtableRecordId) {\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ fields: {} }), // Empty body if you are no longer updating any fields\n    });\n\n    const data = await response.json();\n\n    if (!response.ok) {\n      console.error('Error unlocking Airtable record:', data.error || data);\n      throw new Error(data.error || 'Unknown error');\n    }\n\n    console.log(`Unlocked record ${airtableRecordId} after processing`);\n  } catch (error) {\n    console.error(`Failed to unlock record ${airtableRecordId}`, error);\n  }\n}\n\nasync function updateAirtableWithProcessed(airtableRecordId) {\n  console.log(`Marking Airtable record ${airtableRecordId} as processed`);\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  const updateData = {\n    fields: {\n      Processed: true,  // Mark as processed\n    },\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    const data = await response.json();\n    console.log('Airtable update response:', data);\n\n    if (data.error) {\n      console.error('Error updating Airtable with processed status:', data.error);\n    } else {\n      console.log('Airtable record successfully marked as processed:', data);\n    }\n  } catch (error) {\n    console.error('Error during Airtable API request:', error);\n  }\n}\n\nasync function fetchAirtableEvents(retryCount = 0) {\n  console.log('Fetching unprocessed events from Airtable...');\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ?filterByFormula=OR(NOT({Processed}), {GoogleEventId} != BLANK())`;\n\n  try {\n    const response = await fetch(url, {\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`Error fetching events from Airtable: HTTP ${response.status}`);\n      return [];\n    }\n\n    const data = await response.json();\n    console.log('Raw Airtable data fetched:', data);\n\n    const filteredRecords = data.records\n      .filter((record) => {\n        // Ensure event has a name, start and end dates\n        return record.fields['Calendar Event Name'] && record.fields['StartDate'] && record.fields['EndDate'];\n      })\n      .map((record) => ({\n        id: record.id,\n        title: record.fields['Calendar Event Name'] || 'Untitled Event',\n        start: new Date(record.fields['StartDate']),\n        end: new Date(record.fields['EndDate']),\n        description: record.fields['Billable Reason (If Billable)'] || '',\n        branch: record.fields['b'] || 'Unknown',\n        homeownerName: record.fields['Homeowner Name'] || 'Unknown',\n        materialsNeeded: record.fields['Materials Needed'] || 'Not specified',\n        streetAddress: record.fields['Street Address'] || 'Unknown',\n        city: record.fields['City'] || 'Unknown',\n        state: record.fields['State'] || 'Unknown',\n        zipCode: record.fields['Zip Code'] || 'Unknown',\n        googleEventId: record.fields['GoogleEventId'] || null,\n        processed: record.fields['Processed'] || false,  // Track the Processed field\n      }));\n\n    console.log(`Airtable events to process: ${filteredRecords.length}`, filteredRecords);\n    return filteredRecords;\n\n  } catch (error) {\n    console.error('Error fetching events from Airtable:', error);\n    return [];\n  }\n}\n\nasync function checkForDuplicateEvent(event, calendarId, session) {\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${event.start.toISOString()}&timeMax=${event.end.toISOString()}`;\n\n  try {\n    const response = await fetch(url, {\n      headers: {\n        Authorization: 'Bearer ' + session.provider_token,\n      },\n    });\n\n    const data = await response.json();\n\n    if (data.items && data.items.length > 0) {\n      const existingEvent = data.items.find(\n        (existingEvent) =>\n          existingEvent.summary === event.title && // Match title\n          existingEvent.location === `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}` // Match location\n      );\n\n      if (existingEvent) {\n        // Check for field differences\n        const fieldsToCheck = ['summary', 'description', 'start', 'end', 'location'];\n        const isDifferent = fieldsToCheck.some((field) => {\n          const eventField = field === 'start' || field === 'end' ? event[field].toISOString() : event[field];\n          const existingEventField = field === 'start' || field === 'end' ? existingEvent[field].dateTime : existingEvent[field];\n          return eventField !== existingEventField;\n        });\n\n        // If there's a difference, trigger an update\n        return isDifferent ? existingEvent.id : null;\n      }\n    }\n  } catch (error) {\n    console.error('Error checking for duplicate events in Google Calendar:', error);\n    return null;\n  }\n\n  return null;\n}\n\n\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nasync function populateGoogleCalendarWithAirtableRecords(\n  calendarId,\n  calendarName,\n  session,\n  signOut,\n  setAddedRecords,\n  setFailedRecords,\n  setRateLimitInfo,\n  rateLimitHit,\n  setRateLimitHit\n) {\n  console.log(`Starting to populate Google Calendar \"${calendarName}\" with Airtable records...`);\n\n  const airtableEvents = await fetchAirtableEvents();\n  console.log(`Processing ${airtableEvents.length} Airtable events for Google Calendar sync...`);\n\n  // Define `added` and `failed` arrays here\n  const added = [];\n  const failed = [];\n\n  for (const event of airtableEvents) {\n    if (rateLimitHit) {\n      console.log(`Rate limit hit. Stopping further processing.`);\n      break;\n    }\n\n    console.log(`Processing event \"${event.title}\"...`);\n\n    if (event.branch.toLowerCase() === 'unknown' || event.branch.toLowerCase() !== calendarName.toLowerCase()) {\n      console.log(`Skipping event \"${event.title}\" due to branch mismatch.`);\n      continue;\n    }\n\n    // Lock the record to prevent it from being processed by another process\n    await lockAirtableRecord(event.id);\n\n    try {\n      let googleEventId;\n\n      if (event.googleEventId) {\n        console.log(`Event \"${event.title}\" already has a GoogleEventId: ${event.googleEventId}. Verifying in Google Calendar...`);\n\n        const existingGoogleEventId = await checkForDuplicateEvent(event, calendarId, session);\n\n        // Only proceed if existingGoogleEventId is not null\n        if (existingGoogleEventId) {\n          googleEventId = await updateGoogleCalendarEvent(\n            event,\n            calendarId,\n            existingGoogleEventId,\n            session,\n            signOut,\n            setRateLimitInfo,\n            setRateLimitHit\n          );\n        } else {\n          console.log(`No duplicate found for event \"${event.title}\". Skipping update.`);\n        }\n      } else {\n        // Check Google Calendar for an existing event to avoid duplicates\n        googleEventId = await createGoogleCalendarEvent(\n          event,\n          calendarId,\n          session,\n          signOut,\n          setRateLimitInfo,\n          setRateLimitHit\n        );\n      }\n\n      if (googleEventId) {\n        console.log('Updating Airtable with Google Event ID:', googleEventId);\n\n        // Update Airtable with the Google Event ID and mark as processed\n        await updateAirtableWithGoogleEventIdAndProcessed(event.id, googleEventId);\n        added.push(event.title);\n      } else {\n        failed.push(event.title);\n      }\n    } catch (error) {\n      console.error(`Error processing event \"${event.title}\":`, error);\n      failed.push(event.title);\n    }\n\n    await unlockAirtableRecord(event.id); // Unlock the record after processing\n    await sleep(1000); // Adding delay between requests\n  }\n\n  setAddedRecords((prev) => [...prev, ...added]);\n  setFailedRecords((prev) => [...prev, ...failed]);\n\n  console.log(`Finished populating Google Calendar \"${calendarName}\" with Airtable records.`);\n}\n\n\n\n\n\nfunction CalendarSection({\n  calendarId,\n  calendarName,\n  session,\n  signOut,\n  setAddedRecords,\n  setFailedRecords,\n  setRateLimitInfo,\n  triggerSync,\n  setTriggerSync\n}) {\n  const [lastSyncTime, setLastSyncTime] = useState(null);\n\n  useEffect(() => {\n    const syncEvents = () => {\n      const now = new Date();\n      console.log('Attempting to sync events...');\n  \n      if (session && triggerSync) {\n        if (!session.provider_token) {\n          console.error('No valid session token found. Logging out.');\n          signOut();\n          return;\n        }\n  \n        console.log('Session valid. Initiating sync...');\n        populateGoogleCalendarWithAirtableRecords(\n          calendarId,\n          calendarName,\n          session,\n          signOut,\n          setAddedRecords,\n          setFailedRecords,\n          setRateLimitInfo\n        )\n          .then(() => {\n            console.log(`Finished syncing events to Google Calendar \"${calendarName}\"`);\n            setLastSyncTime(new Date()); // Update last sync time\n            setTriggerSync(false); // Reset the triggerSync after sync\n          })\n          .catch((error) =>\n            console.error(`Error syncing Airtable to Google Calendar \"${calendarName}\":`, error)\n          );\n      }\n    };\n  \n    if (triggerSync) {\n      console.log(`Manual sync triggered for calendar: ${calendarName}`);\n      syncEvents(); // Call syncEvents once here, no recursion\n    }\n  }, [session, signOut, calendarId, calendarName, setAddedRecords, setFailedRecords, setRateLimitInfo, lastSyncTime, triggerSync, setTriggerSync]);\n  \n\n  return (\n    <div className=\"calendar-item\">\n      <h2>{calendarName}</h2>\n    </div>\n  );\n}\n\nfunction App() {\n  const session = useSession();\n  const supabase = useSupabaseClient();\n  const { isLoading } = useSessionContext();\n\n  const [addedRecords, setAddedRecords] = useState([]);\n  const [failedRecords, setFailedRecords] = useState([]);\n  const [triggerSync, setTriggerSync] = useState(false);\n  const [rateLimitHit, setRateLimitHit] = useState(false); // Move this here\n\n  const calendarInfo = [\n    { id: 'c_ebe1fcbce1be361c641591a6c389d4311df7a97961af0020c889686ae059d20a@group.calendar.google.com', name: 'Savannah' }\n  ].sort((a, b) => a.name.localeCompare(b.name));\n\n  const handleSyncNow = () => {\n    console.log('Manual sync button clicked.');\n    setTriggerSync(true); // Trigger manual sync\n  };\n\n  const getGreeting = () => {\n    const currentHour = new Date().getHours();\n    if (currentHour < 12) {\n      return 'Good morning';\n    } else if (currentHour < 18) {\n      return 'Good afternoon';\n    } else {\n      return 'Good evening';\n    }\n  };\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div className=\"App\">\n      <div className=\"container\">\n        <h1>Warranty Calendar</h1>\n        <div style={{ width: '100%', margin: '0 auto' }}>\n          {session ? (\n            <>\n              <h2>{getGreeting()} {session.user.email}</h2>\n              <hr />\n              <button onClick={handleSyncNow}>Sync Now</button> {/* Manual Sync Button */}\n              <div className=\"calendar-grid\">\n                {calendarInfo.map((calendar) => (\n                  <CalendarSection\n                  key={calendar.id}\n                  calendarId={calendar.id}\n                  calendarName={calendar.name}\n                  session={session}\n                  signOut={() => supabase.auth.signOut()}\n                  setAddedRecords={setAddedRecords}\n                  setFailedRecords={setFailedRecords}\n                  triggerSync={triggerSync}\n                  setTriggerSync={setTriggerSync}\n                  rateLimitHit={rateLimitHit} // Pass rateLimitHit as prop\n                  setRateLimitHit={setRateLimitHit} // Pass setter as prop\n                />\n                \n                ))}\n              </div>\n              <div className=\"records-summary\">\n                <h3>Records Summary</h3>\n                <div className=\"summary-container\">\n                  <div className=\"added-records\">\n                    <h4>Successfully Added Records:</h4>\n                    {addedRecords.length > 0 ? (\n                      <ul>\n                        {addedRecords.map((record, index) => (\n                          <li key={index}>{record}</li>\n                        ))}\n                      </ul>\n                    ) : (\n                      <p>No records added.</p>\n                    )}\n                  </div>\n                  <div className=\"failed-records\">\n                    <h4>Failed to Add Records:</h4>\n                    {failedRecords.length > 0 ? (\n                      <ul>\n                        {failedRecords.map((record, index) => (\n                          <li key={index}>{record}</li>\n                        ))}\n                      </ul>\n                    ) : (\n                      <p>No records failed.</p>\n                    )}\n                  </div>\n                </div>\n              </div>\n             \n              <button onClick={() => supabase.auth.signOut()}>Sign Out</button>\n            </>\n          ) : (\n            <>\n             <button onClick={() => supabase.auth.signInWithOAuth({\n  provider: 'google',\n  options: {\n    scopes: 'https://www.googleapis.com/auth/calendar'\n  }\n})}>\n  Sign In With Google\n</button>\n\n            </>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App; // Ensure default export",{"ruleId":"21","severity":1,"message":"22","line":226,"column":16,"nodeType":"23","messageId":"24","endLine":226,"endColumn":43},{"ruleId":"21","severity":1,"message":"25","line":469,"column":13,"nodeType":"23","messageId":"24","endLine":469,"endColumn":16},"no-unused-vars","'updateAirtableWithProcessed' is defined but never used.","Identifier","unusedVar","'now' is assigned a value but never used."]