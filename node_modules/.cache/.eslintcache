[{"/Users/richardmcgirt/Desktop/Warrenty2-/src/index.js":"1","/Users/richardmcgirt/Desktop/Warrenty2-/src/reportWebVitals.js":"2","/Users/richardmcgirt/Desktop/Warrenty2-/src/App.js":"3"},{"size":1042,"mtime":1723728469192,"results":"4","hashOfConfig":"5"},{"size":362,"mtime":1723726139777,"results":"6","hashOfConfig":"5"},{"size":23018,"mtime":1726588058832,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","suppressedMessages":"10","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"11"},"11jqpoc",{"filePath":"12","messages":"13","suppressedMessages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"11"},{"filePath":"15","messages":"16","suppressedMessages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18"},"/Users/richardmcgirt/Desktop/Warrenty2-/src/index.js",[],[],[],"/Users/richardmcgirt/Desktop/Warrenty2-/src/reportWebVitals.js",[],[],"/Users/richardmcgirt/Desktop/Warrenty2-/src/App.js",["19","20","21","22","23"],[],"import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { useSession, useSupabaseClient, useSessionContext } from '@supabase/auth-helpers-react';\n\nconst clientId = process.env.REACT_APP_GOOGLE_CLIENT_ID;\nconst clientSecret = process.env.REACT_APP_GOOGLE_CLIENT_SECRET;\n\nasync function fetchAverageLastUpdated() {\n  console.log('Fetching LastUpdated timestamps for calculating the average...');\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ?fields[]=LastUpdated`;\n\n  try {\n    const response = await fetch(url, {\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`Error fetching LastUpdated timestamps from Airtable: HTTP ${response.status}`);\n      return null;\n    }\n\n    const data = await response.json();\n    const lastUpdatedTimestamps = data.records\n      .filter((record) => record.fields['LastUpdated'])\n      .map((record) => new Date(record.fields['LastUpdated']).getTime());\n\n    if (lastUpdatedTimestamps.length === 0) {\n      return null;\n    }\n\n    const averageTimestamp = lastUpdatedTimestamps.reduce((a, b) => a + b, 0) / lastUpdatedTimestamps.length;\n    const averageDate = new Date(averageTimestamp);\n\n    console.log(`Average LastUpdated: ${averageDate}`);\n    return averageDate;\n  } catch (error) {\n    console.error('Error fetching and calculating the average LastUpdated:', error);\n    return null;\n  }\n}\n\n// Function to display the last sync time in a human-readable format\nfunction formatAverageLastUpdated(date) {\n  if (!date) return 'Never';\n  return date.toLocaleString(); // Customize this if you want a different date format\n}\n\n// Function to check for duplicate events in Google Calendar\nasync function checkForDuplicateEvent(event, calendarId, session) {\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${event.start.toISOString()}&timeMax=${event.end.toISOString()}`;\n\n  try {\n    const response = await fetch(url, {\n      headers: {\n        Authorization: 'Bearer ' + session.provider_token,\n      },\n    });\n\n    const data = await response.json();\n\n    if (data.items && data.items.length > 0) {\n      const existingEvent = data.items.find(\n        (existingEvent) =>\n          existingEvent.summary === event.title && // Match title\n          existingEvent.location === `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}` // Match location\n      );\n\n      if (existingEvent) {\n        const fieldsToCheck = ['summary', 'description', 'start', 'end', 'location'];\n        const isDifferent = fieldsToCheck.some((field) => {\n          const eventField = field === 'start' || field === 'end' ? event[field].toISOString() : event[field];\n          const existingEventField = field === 'start' || field === 'end' ? existingEvent[field].dateTime : existingEvent[field];\n          return eventField !== existingEventField;\n        });\n\n        return isDifferent ? existingEvent.id : null;\n      }\n    }\n  } catch (error) {\n    console.error('Error checking for duplicate events in Google Calendar:', error);\n    return null;\n  }\n\n  return null;\n}\n\n// Function to refresh the Google OAuth token\nasync function refreshAccessToken(refreshToken, clientId, clientSecret) {\n  const url = 'https://oauth2.googleapis.com/token';\n\n  const params = new URLSearchParams();\n  params.append('client_id', clientId);\n  params.append('client_secret', clientSecret);\n  params.append('refresh_token', refreshToken);\n  params.append('grant_type', 'refresh_token');\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: params.toString(),\n    });\n\n    if (response.ok) {\n      const data = await response.json();\n      return {\n        accessToken: data.access_token,\n        expiresIn: data.expires_in,\n      };\n    } else {\n      console.error('Failed to refresh token', await response.json());\n      return null;\n    }\n  } catch (error) {\n    console.error('Error refreshing token:', error);\n    return null;\n  }\n}\n\nasync function updateGoogleCalendarEvent(\n  event,\n  calendarId,\n  eventId,\n  session,\n  signOut,\n  setRateLimitInfo = () => {}, // Default empty function\n  setRateLimitHit = () => {} // Default empty function\n) {\n  console.log(`Updating Google Calendar event for ID: ${eventId}`);\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n\n  const updatedEvent = {\n    summary: event.title,\n    description: `\n      ${event.description}\n      \\nlocation: ${event.location}\n      \\nHomeowner Name: ${event.homeownerName}\n      \\nMaterials Needed: ${event.materialsNeeded || 'Not specified'}\n    `,\n    start: { dateTime: event.start.toISOString() },\n    end: { dateTime: event.end.toISOString() },\n    location: `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}`,\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer ' + session.provider_token,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updatedEvent),\n    });\n\n    if (response.status === 429) {\n      console.error('Rate limit reached. Stopping further requests.');\n      setRateLimitHit(true); // Stop further requests\n      return null;\n    }\n\n    const data = await response.json();\n    const remaining = response.headers.get('X-RateLimit-Remaining');\n    const limit = response.headers.get('X-RateLimit-Limit');\n    const reset = response.headers.get('X-RateLimit-Reset');\n    setRateLimitInfo({ remaining, limit, reset });\n\n    if (response.ok) {\n      console.log('Event successfully updated in Google Calendar with ID:', data.id);\n      return data.id;\n    } else {\n      console.error('Failed to update event:', data);\n      if (data.error && data.error.code === 401) {\n        signOut(); // Handle invalid token by signing out\n      }\n      return null;\n    }\n  } catch (error) {\n    console.error('Error during Google Calendar API request in updateGoogleCalendarEvent:', error);\n    return null;\n  }\n}\nasync function lockAirtableRecord(airtableRecordId) {\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  const updateData = {\n    fields: {\n      Processed: true, // Mark record as being processed\n    },\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238', // Use your actual API key here\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      console.error('Error locking Airtable record:', errorData);\n      return; // Stop further execution if there's an error\n    }\n\n    console.log(`Locked record ${airtableRecordId} for processing`);\n  } catch (error) {\n    console.error(`Failed to lock record ${airtableRecordId}`, error);\n  }\n}\n\nasync function unlockAirtableRecord(airtableRecordId) {\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n\n  const updateData = {\n    fields: {\n      Processed: false, // Uncheck 'Processed' field after sync\n    },\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238', // Use your actual API key here\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    const data = await response.json();\n\n    if (!response.ok) {\n      console.error('Error unlocking Airtable record:', data.error);\n      return; // Stop further execution if there's an error\n    }\n\n    console.log(`Unlocked record ${airtableRecordId} and unchecked 'Processed'`);\n  } catch (error) {\n    console.error(`Failed to unlock record ${airtableRecordId}`, error);\n  }\n}\n\nasync function populateGoogleCalendarWithAirtableRecords(\n  calendarId,\n  calendarName,\n  session,\n  signOut,\n  setAddedRecords,\n  setFailedRecords,\n  setRateLimitInfo,\n  rateLimitHit,\n  setRateLimitHit\n) {\n  console.log(`Starting to populate Google Calendar \"${calendarName}\" with Airtable records...`);\n\n  const airtableEvents = await fetchAirtableEvents();\n  console.log(`Processing ${airtableEvents.length} Airtable events for Google Calendar sync...`);\n\n  const added = [];\n  const failed = [];\n\n  for (const event of airtableEvents) {\n    if (rateLimitHit) {\n      console.log(`Rate limit hit. Stopping further processing.`);\n      break;\n    }\n\n    console.log(`Processing event \"${event.title}\"...`);\n\n    if (event.branch.toLowerCase() === 'unknown' || event.branch.toLowerCase() !== calendarName.toLowerCase()) {\n      console.log(`Skipping event \"${event.title}\" due to branch mismatch.`);\n      continue;\n    }\n\n    // Lock the record to prevent it from being processed by another process\n    await lockAirtableRecord(event.id);\n\n    try {\n      let googleEventId;\n\n      if (event.googleEventId) {\n        console.log(`Event \"${event.title}\" already has a GoogleEventId: ${event.googleEventId}. Verifying in Google Calendar...`);\n\n        const existingGoogleEventId = await checkForDuplicateEvent(event, calendarId, session);\n\n        if (existingGoogleEventId) {\n          googleEventId = await updateGoogleCalendarEvent(\n            event,\n            calendarId,\n            existingGoogleEventId,\n            session,\n            signOut,\n            setRateLimitInfo,\n            setRateLimitHit\n          );\n        } else {\n          console.log(`No duplicate found for event \"${event.title}\". Skipping update.`);\n        }\n      } else {\n        googleEventId = await createGoogleCalendarEvent(\n          event,\n          calendarId,\n          session,\n          signOut,\n          setRateLimitInfo,\n          setRateLimitHit\n        );\n      }\n\n      if (googleEventId) {\n        console.log('Updating Airtable with Google Event ID:', googleEventId);\n        await updateAirtableWithGoogleEventIdAndProcessed(event.id, googleEventId);\n        added.push(event.title);\n      } else {\n        failed.push(event.title);\n      }\n\n      // Delay of 2 seconds before unlocking the record\n      await sleep(2000); // 2-second delay\n      \n      // Unlock the record and uncheck the 'Processed' field\n      await unlockAirtableRecord(event.id);\n      \n    } catch (error) {\n      console.error(`Error processing event \"${event.title}\":`, error);\n      failed.push(event.title);\n    }\n  }\n\n  setAddedRecords((prev) => [...prev, ...added]);\n  setFailedRecords((prev) => [...prev, ...failed]);\n\n  console.log(`Finished populating Google Calendar \"${calendarName}\" with Airtable records.`);\n}\n\n// Utility function to simulate a delay (for rate-limiting purposes)\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nasync function createGoogleCalendarEvent(event, calendarId, session, signOut, setRateLimitInfo = () => {}, setRateLimitHit) {\n  console.log(`Attempting to create a new Google Calendar event for calendar: ${calendarId}`, event);\n\n  const existingGoogleEventId = await checkForDuplicateEvent(event, calendarId, session);\n  if (existingGoogleEventId) {\n    console.log('Duplicate event detected in final check, skipping creation:', existingGoogleEventId);\n    return existingGoogleEventId;\n  }\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n\n  const updatedEvent = {\n    summary: event.title,\n    description: `\n      ${event.description}\n      \\nlocation: ${event.location}\n      \\nHomeowner Name: ${event.homeownerName}\n      \\nMaterials Needed: ${event.materialsNeeded || 'Not specified'}\n    `,\n    start: { dateTime: event.start.toISOString() },\n    end: { dateTime: event.end.toISOString() },\n    location: `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}`,\n  };\n\n  console.log('Event data being sent to Google Calendar API:', updatedEvent);\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${session.provider_token}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updatedEvent),\n    });\n\n    if (response.status === 429) {\n      console.error('Rate limit reached. Stopping further requests.');\n      setRateLimitHit(true);\n      return null;\n    }\n\n    const data = await response.json();\n    if (response.ok) {\n      console.log('Event successfully created in Google Calendar with ID:', data.id);\n      await updateAirtableWithGoogleEventIdAndProcessed(event.id, data.id);\n      return data.id;\n    } else {\n      console.error('Failed to create event:', data);\n      return null;\n    }\n  } catch (error) {\n    console.error('Error during Google Calendar API request:', error);\n    return null;\n  }\n}\n\nasync function updateAirtableWithGoogleEventIdAndProcessed(airtableRecordId, googleEventId) {\n  console.log(`Updating Airtable record ${airtableRecordId} with Google Event ID: ${googleEventId}`);\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n\n  const updateData = {\n    fields: {\n      GoogleEventId: googleEventId,\n      Processed: true,\n      LastUpdated: new Date().toISOString(),\n    },\n  };\n\n  console.log('Data being sent to Airtable for update:', updateData);\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    const data = await response.json();\n    if (!response.ok) {\n      console.error('Error updating Airtable:', data.error);\n    } else {\n      console.log('Airtable record successfully updated:', data);\n    }\n  } catch (error) {\n    console.error('Error during Airtable API request:', error);\n  }\n}\n\nasync function fetchAirtableEvents(retryCount = 0) {\n  console.log('Fetching unprocessed events from Airtable...');\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ?filterByFormula=OR(NOT({Processed}), {GoogleEventId} != BLANK())`;\n\n  try {\n    const response = await fetch(url, {\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`Error fetching events from Airtable: HTTP ${response.status}`);\n      return [];\n    }\n\n    const data = await response.json();\n    console.log('Raw Airtable data fetched:', data);\n\n    // Get the current date\n    const now = new Date();\n    const startOfToday = new Date(now.setHours(0, 0, 0, 0)); // Start of the current day\n\n    // Filter records to include only those where StartDate is today or in the future\n    const filteredRecords = data.records\n      .filter((record) => {\n        // Ensure the event has a name, start, and end dates\n        if (!record.fields['Calendar Event Name'] || !record.fields['StartDate'] || !record.fields['EndDate']) {\n          return false;\n        }\n\n        const startDate = new Date(record.fields['StartDate']);\n        // Only include records with a StartDate that is today or in the future\n        return startDate >= startOfToday;\n      })\n      .map((record) => ({\n        id: record.id,\n        title: record.fields['Calendar Event Name'] || 'Untitled Event',\n        start: new Date(record.fields['StartDate']),\n        end: new Date(record.fields['EndDate']),\n        description: record.fields['Billable Reason (If Billable)'] || '',\n        branch: record.fields['b'] || 'Unknown',\n        homeownerName: record.fields['Homeowner Name'] || 'Unknown',\n        materialsNeeded: record.fields['Materials Needed'] || 'Not specified',\n        streetAddress: record.fields['Street Address'] || 'Unknown',\n        city: record.fields['City'] || 'Unknown',\n        state: record.fields['State'] || 'Unknown',\n        zipCode: record.fields['Zip Code'] || 'Unknown',\n        googleEventId: record.fields['GoogleEventId'] || null,\n        processed: record.fields['Processed'] || false,  // Track the Processed field\n      }));\n\n    console.log(`Airtable events to process: ${filteredRecords.length}`, filteredRecords);\n    return filteredRecords;\n\n  } catch (error) {\n    console.error('Error fetching events from Airtable:', error);\n    return [];\n  }\n}\n\n\n\nfunction CalendarSection({ calendarId, calendarName, session, signOut, setAddedRecords, setFailedRecords, setRateLimitInfo, triggerSync, setTriggerSync, rateLimitHit, setRateLimitHit, lastSynced }) {\n  useEffect(() => {\n    if (triggerSync) {\n      console.log(`Syncing calendar: ${calendarName}`);\n      populateGoogleCalendarWithAirtableRecords(\n        calendarId,\n        calendarName,\n        session,\n        signOut,\n        setAddedRecords,\n        setFailedRecords,\n        setRateLimitInfo,\n        rateLimitHit,\n        setRateLimitHit\n      ).then(() => {\n        setTriggerSync(false);\n      });\n    }\n  }, [triggerSync, calendarId, calendarName, session, signOut, setAddedRecords, setFailedRecords, setRateLimitInfo, rateLimitHit, setRateLimitHit]);\n\n  return (\n    <div className=\"calendar-item\">\n      <h2>{calendarName}</h2>\n      <p>Last synced: {lastSynced ? lastSynced.toLocaleString() : 'Never'}</p>\n    </div>\n  );\n}\n\nfunction App() {\n  const session = useSession();\n  const supabase = useSupabaseClient();\n  const { isLoading } = useSessionContext();\n\n  const [addedRecords, setAddedRecords] = useState([]);\n  const [failedRecords, setFailedRecords] = useState([]);\n  const [triggerSync, setTriggerSync] = useState(false);\n  const [rateLimitHit, setRateLimitHit] = useState(false);\n  const [averageLastUpdated, setAverageLastUpdated] = useState(null);\n\n  const calendarInfo = [\n    { id: 'c_ebe1fcbce1be361c641591a6c389d4311df7a97961af0020c889686ae059d20a@group.calendar.google.com', name: 'Savannah' },\n  ].sort((a, b) => a.name.localeCompare(b.name));\n\n  const handleSyncNow = () => {\n    console.log('Manual sync button clicked.');\n    setTriggerSync(true); // Trigger manual sync\n  };\n\n  const getGreeting = () => {\n    const currentHour = new Date().getHours();\n    if (currentHour < 12) {\n      return 'Good morning';\n    } else if (currentHour < 18) {\n      return 'Good afternoon';\n    } else {\n      return 'Good evening';\n    }\n  };\n\n  useEffect(() => {\n    // Fetch and display the average LastUpdated time when the app loads\n    const fetchAndSetAverageLastUpdated = async () => {\n      const averageDate = await fetchAverageLastUpdated();\n      setAverageLastUpdated(averageDate);\n    };\n    fetchAndSetAverageLastUpdated();\n  }, []);\n\n  useEffect(() => {\n    if (!triggerSync) return;\n\n    console.log('Triggering sync process...');\n\n    const syncEvents = async () => {\n      for (const calendar of calendarInfo) {\n        console.log(`Syncing calendar: ${calendar.name}`);\n        await populateGoogleCalendarWithAirtableRecords(\n          calendar.id,\n          calendar.name,\n          session,\n          () => supabase.auth.signOut(),\n          setAddedRecords,\n          setFailedRecords,\n          () => {}, // Replace with rate limit function if needed\n          rateLimitHit,\n          setRateLimitHit\n        );\n      }\n\n      // After sync, recalculate and update the average LastUpdated time\n      const newAverageDate = await fetchAverageLastUpdated();\n      setAverageLastUpdated(newAverageDate);\n    };\n\n    syncEvents().finally(() => setTriggerSync(false));\n  }, [triggerSync]);\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div className=\"App\">\n      <div className=\"container\">\n        <h1>Warranty Calendar</h1>\n        <div style={{ width: '100%', margin: '0 auto' }}>\n          {session ? (\n            <>\n              <h2>{getGreeting()} {session.user.email}</h2>\n              <hr />\n              <button onClick={handleSyncNow}>Sync Now</button> {/* Manual Sync Button */}\n              <p>Last Synced: {formatAverageLastUpdated(averageLastUpdated)}</p> {/* Display average LastUpdated */}\n              <div className=\"calendar-grid\">\n                {calendarInfo.map((calendar) => (\n                  <CalendarSection\n                    key={calendar.id}\n                    calendarId={calendar.id}\n                    calendarName={calendar.name}\n                    session={session}\n                    signOut={() => supabase.auth.signOut()}\n                    setAddedRecords={setAddedRecords}\n                    setFailedRecords={setFailedRecords}\n                    triggerSync={triggerSync}\n                    setTriggerSync={setTriggerSync}\n                    rateLimitHit={rateLimitHit} // Pass rateLimitHit as prop\n                    setRateLimitHit={setRateLimitHit} // Pass setter as prop\n                  />\n                ))}\n              </div>\n              <div className=\"records-summary\">\n                <h3>Records Summary</h3>\n                <div className=\"summary-container\">\n                  <div className=\"added-records\">\n                    <h4>Successfully Added Records:</h4>\n                    {addedRecords.length > 0 ? (\n                      <ul>\n                        {addedRecords.map((record, index) => (\n                          <li key={index}>{record}</li>\n                        ))}\n                      </ul>\n                    ) : (\n                      <p>No records added.</p>\n                    )}\n                  </div>\n                  <div className=\"failed-records\">\n                    <h4>Failed to Add Records:</h4>\n                    {failedRecords.length > 0 ? (\n                      <ul>\n                        {failedRecords.map((record, index) => (\n                          <li key={index}>{record}</li>\n                        ))}\n                      </ul>\n                    ) : (\n                      <p>No records failed.</p>\n                    )}\n                  </div>\n                </div>\n              </div>\n              <button onClick={() => supabase.auth.signOut()}>Sign Out</button>\n            </>\n          ) : (\n            <>\n              <button onClick={() => supabase.auth.signInWithOAuth({\n                provider: 'google',\n                options: {\n                  scopes: 'https://www.googleapis.com/auth/calendar',\n                },\n              })}>\n                Sign In With Google\n              </button>\n            </>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",{"ruleId":"24","severity":1,"message":"25","line":5,"column":7,"nodeType":"26","messageId":"27","endLine":5,"endColumn":15},{"ruleId":"24","severity":1,"message":"28","line":6,"column":7,"nodeType":"26","messageId":"27","endLine":6,"endColumn":19},{"ruleId":"24","severity":1,"message":"29","line":91,"column":16,"nodeType":"26","messageId":"27","endLine":91,"endColumn":34},{"ruleId":"30","severity":1,"message":"31","line":524,"column":6,"nodeType":"32","endLine":524,"endColumn":147,"suggestions":"33"},{"ruleId":"30","severity":1,"message":"34","line":601,"column":6,"nodeType":"32","endLine":601,"endColumn":19,"suggestions":"35"},"no-unused-vars","'clientId' is assigned a value but never used.","Identifier","unusedVar","'clientSecret' is assigned a value but never used.","'refreshAccessToken' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'setTriggerSync'. Either include it or remove the dependency array. If 'setTriggerSync' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["36"],"React Hook useEffect has missing dependencies: 'calendarInfo', 'rateLimitHit', 'session', and 'supabase.auth'. Either include them or remove the dependency array.",["37"],{"desc":"38","fix":"39"},{"desc":"40","fix":"41"},"Update the dependencies array to be: [triggerSync, calendarId, calendarName, session, signOut, setAddedRecords, setFailedRecords, setRateLimitInfo, rateLimitHit, setRateLimitHit, setTriggerSync]",{"range":"42","text":"43"},"Update the dependencies array to be: [calendarInfo, rateLimitHit, session, supabase.auth, triggerSync]",{"range":"44","text":"45"},[17506,17647],"[triggerSync, calendarId, calendarName, session, signOut, setAddedRecords, setFailedRecords, setRateLimitInfo, rateLimitHit, setRateLimitHit, setTriggerSync]",[20002,20015],"[calendarInfo, rateLimitHit, session, supabase.auth, triggerSync]"]