[{"/Users/richardmcgirt/Desktop/Warrenty2-/src/index.js":"1","/Users/richardmcgirt/Desktop/Warrenty2-/src/reportWebVitals.js":"2","/Users/richardmcgirt/Desktop/Warrenty2-/src/App.js":"3"},{"size":1042,"mtime":1723728469192,"results":"4","hashOfConfig":"5"},{"size":362,"mtime":1723726139777,"results":"6","hashOfConfig":"5"},{"size":24728,"mtime":1727094542578,"results":"7","hashOfConfig":"5"},{"filePath":"8","messages":"9","suppressedMessages":"10","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"11"},"11jqpoc",{"filePath":"12","messages":"13","suppressedMessages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"11"},{"filePath":"15","messages":"16","suppressedMessages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18"},"/Users/richardmcgirt/Desktop/Warrenty2-/src/index.js",[],[],[],"/Users/richardmcgirt/Desktop/Warrenty2-/src/reportWebVitals.js",[],[],"/Users/richardmcgirt/Desktop/Warrenty2-/src/App.js",["19","20","21","22"],[],"import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { useSession, useSupabaseClient, useSessionContext } from '@supabase/auth-helpers-react';\n\n\n\nasync function createGoogleCalendarEvent(event, calendarId, session, signOut, setRateLimitInfo, setRateLimitHit) {\n  console.log(`Attempting to create a new Google Calendar event for calendar: ${calendarId}`, event);\n\n  // Final duplicate check before creating\n  const existingGoogleEventId = await checkForDuplicateEvent(event, calendarId, session);\n  if (existingGoogleEventId) {\n    console.log('Duplicate event detected in final check, skipping creation:', existingGoogleEventId);\n    return existingGoogleEventId;\n  }\n\n  // Proceed with event creation\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n\n  const updatedEvent = {\n    summary: event.title,\n    description: `\n      ${event.description}\n      \\nlocation: ${event.location}\n      \\nHomeowner Name: ${event.homeownerName}\n      \\nMaterials Needed: ${event.materialsNeeded || 'Not specified'}\n    `,\n    start: { dateTime: event.start.toISOString() },\n    end: { dateTime: event.end.toISOString() },\n    location: `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}`,\n  };\n\n  console.log('Event data being sent to Google Calendar API:', updatedEvent);\n\n  try {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        Authorization: 'Bearer ' + session.provider_token,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updatedEvent),\n    });\n\n    console.log('Response status:', response.status); // Log the response status\n\n    if (response.status === 429) {\n      console.error('Rate limit reached. Stopping further requests.');\n      const limitInfo = {\n        remaining: response.headers.get('X-RateLimit-Remaining'),\n        limit: response.headers.get('X-RateLimit-Limit'),\n        reset: response.headers.get('X-RateLimit-Reset'),\n      };\n      console.log('Rate limit info:', limitInfo);\n      setRateLimitHit(true);\n      return null;\n    }\n\n    const data = await response.json();\n    console.log('Google API response data:', data); // Log the entire response\n\n    if (response.ok) {\n      console.log('Event successfully created in Google Calendar with ID:', data.id);\n\n      // Update Airtable with the Google Event ID\n      await updateAirtableWithGoogleEventIdAndProcessed(event.id, data.id);\n\n      return data.id;\n    } else {\n      console.error('Failed to create event:', data);\n      return null;\n    }\n  } catch (error) {\n    console.error('Error during Google Calendar API request:', error);\n    return null;\n  }\n}\n\n\n\nasync function updateGoogleCalendarEvent(\n  event,\n  calendarId,\n  eventId,\n  session,\n  signOut,\n  setRateLimitInfo = () => {},\n  setRateLimitHit = () => {}\n) {\n  console.log(`Updating Google Calendar event for ID: ${eventId}`);\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n\n  const updatedEvent = {\n    summary: event.title,\n    description: `\n      ${event.description}\n      \\nlocation: ${event.location}\n      \\nHomeowner Name: ${event.homeownerName}\n      \\nMaterials Needed: ${event.materialsNeeded || 'Not specified'}\n    `,\n    start: { dateTime: event.start.toISOString() },\n    end: { dateTime: event.end.toISOString() },\n    location: `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}`,\n  };\n\n  console.log('Event data being sent to update Google Calendar API:', updatedEvent);\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer ' + session.provider_token,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updatedEvent),\n    });\n\n    console.log('Response status:', response.status); // Log response status\n\n    if (response.status === 429) {\n      const retryAfter = response.headers.get('Retry-After');\n      console.error(`Rate limit reached. Retry after ${retryAfter} seconds.`);\n      setRateLimitHit(true);\n    \n      // Retry logic\n      if (retryAfter) {\n        setTimeout(() => {\n          // Call the function again after the retry period\n          createGoogleCalendarEvent(event, calendarId, session, signOut, setRateLimitInfo, setRateLimitHit);\n        }, retryAfter * 1000); // Retry after the time specified in the header\n      }\n      return null;\n    }\n    \n\n    const data = await response.json();\n    console.log('Response headers:', response.headers); // Log response headers\n    console.log('Response data:', data); // Log response body\n\n    if (response.ok) {\n      console.log('Event successfully updated in Google Calendar with ID:', data.id);\n      return data.id;\n    } else {\n      console.error('Failed to update event:', data);\n      if (data.error && data.error.code === 401) {\n        signOut(); // Handle invalid token by signing out\n      }\n      return null;\n    }\n  } catch (error) {\n    console.error('Error during Google Calendar API request in updateGoogleCalendarEvent:', error);\n    return null;\n  }\n}\n\nfunction formatDateToCustomString(date) {\n  const options = {\n    year: 'numeric',\n    month: 'numeric',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: 'numeric',\n    hour12: true, // Use 12-hour time with AM/PM\n  };\n\n  return new Intl.DateTimeFormat('en-US', options).format(date);\n}\n\n\nasync function updateAirtableWithGoogleEventIdAndProcessed(airtableRecordId, googleEventId) {\n  console.log(`Updating Airtable record ${airtableRecordId} with Google Event ID: ${googleEventId} and marking as processed`);\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n\n  // Format the current date in custom MM/DD/YYYY hh:mm am/pm format\n  const formattedDate = formatDateToCustomString(new Date());\n\n  // Ensure data matches Airtable fields exactly\n  const updateData = {\n    fields: {\n      GoogleEventId: googleEventId,  // Ensure this matches the Airtable field name exactly\n      Processed: true,               // Ensure this is a boolean if Airtable expects a checkbox\n      LastUpdated: formattedDate,    // Use the custom formatted date string\n    },\n  };\n\n  // Log the formatted date and updateData object to ensure it's correct\n  console.log('Formatted LastUpdated date:', formattedDate);\n  console.log('Data being sent to Airtable:', JSON.stringify(updateData, null, 2));  // Pretty print the data for better readability\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',  // Replace with your actual API key\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    console.log('Response status:', response.status); // Log the response status\n    const data = await response.json();\n    \n    // Log the response data for further inspection\n    console.log('Response data:', JSON.stringify(data, null, 2));\n\n    if (!response.ok) {\n      // Log more details when there is an error\n      console.error('Error updating Airtable:', data.error);  // Inspect the error\n    } else {\n      console.log('Airtable record successfully updated:', JSON.stringify(data, null, 2));\n    }\n  } catch (error) {\n    // Log full error information\n    console.error('Error during Airtable API request:', error);\n    console.error('Error stack trace:', error.stack);\n  }\n}\n\n\n\nasync function lockAirtableRecord(airtableRecordId) {\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  const updateData = {\n    fields: {\n      Processed: true, // Mark record as being processed\n    },\n  };\n\n  try {\n    await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n    console.log(`Locked record ${airtableRecordId} for Processed`);\n  } catch (error) {\n    console.error(`Failed to lock record ${airtableRecordId}`, error);\n  }\n}\n\nasync function unlockAirtableRecord(airtableRecordId) {\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ fields: {} }), // Empty body if you are no longer updating any fields\n    });\n\n    const data = await response.json();\n\n    if (!response.ok) {\n      console.error('Error unlocking Airtable record:', data.error || data);\n      throw new Error(data.error || 'Unknown error');\n    }\n\n    console.log(`Unlocked record ${airtableRecordId} after processing`);\n  } catch (error) {\n    console.error(`Failed to unlock record ${airtableRecordId}`, error);\n  }\n}\n\n\n\nasync function fetchAirtableEvents(retryCount = 0) {\n  console.log('Fetching unprocessed events from Airtable...');\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ?filterByFormula=OR(NOT({Processed}), {GoogleEventId} != BLANK())`;\n\n  try {\n    const response = await fetch(url, {\n      headers: {\n        'Authorization': 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`Error fetching events from Airtable: HTTP ${response.status}`);\n      return [];\n    }\n\n    const data = await response.json();\n    console.log('Raw Airtable data fetched:', data);\n\n    const filteredRecords = data.records\n      .filter((record) => {\n        // Ensure event has a name, start and end dates\n        return record.fields['Calendar Event Name'] && record.fields['StartDate'] && record.fields['EndDate'];\n      })\n      .map((record) => ({\n        id: record.id,\n        title: record.fields['Calendar Event Name'] || 'Untitled Event',\n        start: new Date(record.fields['StartDate']),\n        end: new Date(record.fields['EndDate']),\n        description: record.fields['Billable Reason (If Billable)'] || '',\n        branch: record.fields['b'] || 'Unknown',\n        homeownerName: record.fields['Homeowner Name'] || 'Unknown',\n        materialsNeeded: record.fields['Materials Needed'] || 'Not specified',\n        streetAddress: record.fields['Street Address'] || 'Unknown',\n        city: record.fields['City'] || 'Unknown',\n        state: record.fields['State'] || 'Unknown',\n        zipCode: record.fields['Zip Code'] || 'Unknown',\n        googleEventId: record.fields['GoogleEventId'] || null,\n        processed: record.fields['Processed'] || false,  // Track the Processed field\n      }));\n\n    console.log(`Airtable events to process: ${filteredRecords.length}`, filteredRecords);\n    return filteredRecords;\n\n  } catch (error) {\n    console.error('Error fetching events from Airtable:', error);\n    return [];\n  }\n}\n\nasync function checkForDuplicateEvent(event, calendarId, session, signOut) {\n  if (!session || !session.provider_token) {\n    console.error('No valid session token found. User must sign in again.');\n    signOut(); // Ensure signOut is called\n    return null;\n  }\n\n  console.log('Session provider token:', session.provider_token); // Debugging token\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${event.start.toISOString()}&timeMax=${event.end.toISOString()}`;\n\n  try {\n    const response = await fetch(url, {\n      headers: {\n        Authorization: 'Bearer ' + session.provider_token,\n      },\n    });\n\n    // Check for 401 Unauthorized and handle it\n    if (response.status === 401) {\n      console.error('Unauthorized access, likely due to an expired token. Signing out...');\n      signOut(); // Use the signOut function passed down\n      return null;\n    }\n\n    const data = await response.json();\n    console.log('Google Calendar API response:', data);\n\n    if (data.items && data.items.length > 0) {\n      const existingEvent = data.items.find(\n        (existingEvent) =>\n          existingEvent.summary === event.title && // Match title\n          existingEvent.location === `${event.streetAddress}, ${event.city}, ${event.state}, ${event.zipCode}` // Match location\n      );\n\n      if (existingEvent) {\n        console.log('Found existing event:', existingEvent);\n        return existingEvent.id;\n      }\n    }\n  } catch (error) {\n    console.error('Error checking for duplicate events in Google Calendar:', error);\n  }\n\n  return null;\n}\n\n\nasync function fetchGoogleCalendarEvents(calendarId, session, timeMin, timeMax) {\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${timeMin}&timeMax=${timeMax}`;\n  \n  try {\n    const response = await fetch(url, {\n      headers: {\n        Authorization: 'Bearer ' + session.provider_token,\n      },\n    });\n    \n    if (!response.ok) {\n      throw new Error('Failed to fetch events from Google Calendar');\n    }\n    \n    const data = await response.json();\n    return data.items || [];\n  } catch (error) {\n    console.error('Error fetching events from Google Calendar:', error);\n    return [];\n  }\n}\n\nfunction compareAndUpdateEvent(airtableEvent, googleEvent, session, calendarId, signOut, setRateLimitInfo, setRateLimitHit) {\n  // Compare fields to detect changes\n  const hasChanges = (\n    airtableEvent.title !== googleEvent.summary ||\n    airtableEvent.description !== googleEvent.description ||\n    airtableEvent.start.toISOString() !== googleEvent.start.dateTime ||\n    airtableEvent.end.toISOString() !== googleEvent.end.dateTime ||\n    airtableEvent.location !== googleEvent.location\n  );\n  \n  if (hasChanges) {\n    // Update the Google Calendar event\n    return updateGoogleCalendarEvent(\n      airtableEvent,\n      calendarId,\n      googleEvent.id,\n      session,\n      signOut,\n      setRateLimitInfo,\n      setRateLimitHit\n    );\n  } else {\n    console.log(`No changes detected for event: ${airtableEvent.title}`);\n    return Promise.resolve(null); // No changes, no update\n  }\n}\n\n\n\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nasync function populateGoogleCalendarWithAirtableRecords(\n  calendarId,\n  calendarName,\n  session,\n  signOut,\n  setAddedRecords,\n  setFailedRecords,\n  setUpdatedRecords,\n  setRateLimitInfo,\n  rateLimitHit,\n  setRateLimitHit\n) {\n  console.log(`Starting to populate Google Calendar \"${calendarName}\" with Airtable records...`);\n  \n  const airtableEvents = await fetchAirtableEvents();\n  console.log(`Processing ${airtableEvents.length} Airtable events for Google Calendar sync...`);\n  \n  const timeMin = new Date().toISOString(); // Specify the start of the time range (e.g., now)\n  const timeMax = new Date(new Date().setFullYear(new Date().getFullYear() + 1)).toISOString(); // One year from now\n  \n  const googleCalendarEvents = await fetchGoogleCalendarEvents(calendarId, session, timeMin, timeMax);\n  console.log(`Fetched ${googleCalendarEvents.length} Google Calendar events for comparison.`);\n  \n  const added = [];\n  const failed = [];\n  const updated = []; // Track updated events\n\n  for (const event of airtableEvents) {\n    if (rateLimitHit) {\n      console.log(`Rate limit hit. Stopping further processing.`);\n      break;\n    }\n\n    console.log(`Processing event \"${event.title}\"...`);\n    \n    const matchingGoogleEvent = googleCalendarEvents.find(\n      (googleEvent) => googleEvent.summary === event.title && googleEvent.start.dateTime === event.start.toISOString()\n    );\n    \n    if (matchingGoogleEvent) {\n      console.log(`Found matching event in Google Calendar: \"${event.title}\". Comparing for updates...`);\n      const googleEventId = await compareAndUpdateEvent(\n        event,\n        matchingGoogleEvent,\n        session,\n        calendarId,\n        signOut,\n        setRateLimitInfo,\n        setRateLimitHit\n      );\n      \n      if (googleEventId) {\n        updated.push(event.title); // If updated, add to updated records\n      }\n    } else {\n      console.log(`No matching event found for \"${event.title}\". Creating new event in Google Calendar...`);\n      const googleEventId = await createGoogleCalendarEvent(\n        event,\n        calendarId,\n        session,\n        signOut,\n        setRateLimitInfo,\n        setRateLimitHit\n      );\n      \n      if (googleEventId) {\n        added.push(event.title);\n      } else {\n        failed.push(event.title);\n      }\n    }\n  }\n  \n  setAddedRecords((prev) => [...prev, ...added]);\n  setFailedRecords((prev) => [...prev, ...failed]);\n  setUpdatedRecords((prev) => [...prev, ...updated]);\n  \n  console.log(`Finished populating Google Calendar \"${calendarName}\" with Airtable records.`);\n}\n\n\nfunction CalendarSection({\n  calendarId,\n  calendarName,\n  session,\n  signOut,\n  setAddedRecords,\n  setFailedRecords,\n  setUpdatedRecords, // Pass setUpdatedRecords\n  setRateLimitInfo,\n  triggerSync,\n  setTriggerSync\n}) {\n  const [lastSyncTime, setLastSyncTime] = useState(null);\n\n  useEffect(() => {\n    const syncEvents = () => {\n      console.log('Attempting to sync events...');\n  \n      if (session && triggerSync) {\n        if (!session.provider_token) {\n          console.error('No valid session token found. Logging out.');\n          signOut();\n          return;\n        }\n  \n        console.log('Session valid. Initiating sync...');\n        populateGoogleCalendarWithAirtableRecords(\n          calendarId,\n          calendarName,\n          session,\n          signOut,\n          setAddedRecords,\n          setFailedRecords,\n          setUpdatedRecords, // Pass updated records setter\n          setRateLimitInfo\n        )\n          .then(() => {\n            console.log(`Finished syncing events to Google Calendar \"${calendarName}\"`);\n            setLastSyncTime(new Date());\n            setTriggerSync(false);\n          })\n          .catch((error) =>\n            console.error(`Error syncing Airtable to Google Calendar \"${calendarName}\":`, error)\n          );\n      }\n    };\n  \n    if (triggerSync) {\n      console.log(`Manual sync triggered for calendar: ${calendarName}`);\n      syncEvents();\n    }\n  }, [session, signOut, calendarId, calendarName, setAddedRecords, setFailedRecords, setUpdatedRecords, setRateLimitInfo, lastSyncTime, triggerSync, setTriggerSync]);\n\n  return (\n    <div className=\"calendar-item\">\n      <h2>{calendarName}</h2>\n    </div>\n  );\n}\n\n\n\nfunction App() {\n  const session = useSession();\n  const supabase = useSupabaseClient();\n  const { isLoading } = useSessionContext();\n\n  const [addedRecords, setAddedRecords] = useState([]);\n  const [failedRecords, setFailedRecords] = useState([]);\n  const [updatedRecords, setUpdatedRecords] = useState([]);\n  const [triggerSync, setTriggerSync] = useState(false);\n  const [rateLimitHit, setRateLimitHit] = useState(false);\n  const [timeRemaining, setTimeRemaining] = useState(900); // 15 minutes countdown (900 seconds)\n\n  const calendarInfo = [\n    { id: 'c_ebe1fcbce1be361c641591a6c389d4311df7a97961af0020c889686ae059d20a@group.calendar.google.com', name: 'Savannah' }\n  ];\n\n  // Function to handle the sync process\n  const handleSyncNow = () => {\n    console.log('Manual sync button clicked.');\n    setTriggerSync(true);\n    setTimeRemaining(900); // Reset the countdown after manual sync\n  };\n\n  // Countdown Timer\n  useEffect(() => {\n    const countdownInterval = setInterval(() => {\n      setTimeRemaining((prevTime) => {\n        if (prevTime <= 0) {\n          setTriggerSync(true); // Trigger the sync when the countdown reaches 0\n          return 900; // Reset the countdown to 15 minutes\n        }\n        return prevTime - 1;\n      });\n    }, 1000); // Decrease the countdown by 1 second\n\n    // Cleanup the interval when the component unmounts\n    return () => clearInterval(countdownInterval);\n  }, []);\n\n  // Automatically trigger sync every 15 minutes (triggerSync is set to true after countdown reaches 0)\n  useEffect(() => {\n    if (triggerSync && session) {\n      console.log('Auto-sync triggered.');\n      populateGoogleCalendarWithAirtableRecords(\n        calendarInfo[0].id,\n        calendarInfo[0].name,\n        session,\n        () => supabase.auth.signOut(),\n        setAddedRecords,\n        setFailedRecords,\n        setUpdatedRecords,\n        () => {}, // Set rate limit info (optional)\n        rateLimitHit,\n        setRateLimitHit\n      ).then(() => {\n        setTriggerSync(false);\n      });\n    }\n  }, [triggerSync, session]);\n\n  const getGreeting = () => {\n    const currentHour = new Date().getHours();\n    if (currentHour < 12) {\n      return 'Good morning';\n    } else if (currentHour < 18) {\n      return 'Good afternoon';\n    } else {\n      return 'Good evening';\n    }\n  };\n\n  if (isLoading) {\n    return <div>Loading...</div>;\n  }\n\n  // Convert seconds to minutes and seconds for display\n  const formatTimeRemaining = () => {\n    const minutes = Math.floor(timeRemaining / 60);\n    const seconds = timeRemaining % 60;\n    return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;\n  };\n\n  return (\n    <div className=\"App\">\n      <div className=\"container\">\n        <h1>Warranty Calendar</h1>\n        <div style={{ width: '100%', margin: '0 auto' }}>\n          {session ? (\n            <>\n              <h2>{getGreeting()} {session.user.email}</h2>\n              <hr />\n              <button onClick={handleSyncNow}>Sync Now</button>\n              <p>Next auto-sync in: {formatTimeRemaining()}</p> {/* Countdown Timer Display */}\n              <div className=\"calendar-grid\">\n                {calendarInfo.map((calendar) => (\n                  <CalendarSection\n                    key={calendar.id}\n                    calendarId={calendar.id}\n                    calendarName={calendar.name}\n                    session={session}\n                    signOut={() => supabase.auth.signOut()}\n                    setAddedRecords={setAddedRecords}\n                    setFailedRecords={setFailedRecords}\n                    setUpdatedRecords={setUpdatedRecords}\n                    triggerSync={triggerSync}\n                    setTriggerSync={setTriggerSync}\n                    rateLimitHit={rateLimitHit}\n                    setRateLimitHit={setRateLimitHit}\n                  />\n                ))}\n              </div>\n              <div className=\"records-summary\">\n                <h3>Records Summary</h3>\n                <div className=\"summary-container\">\n                  <div className=\"added-records\">\n                    <h4>Successfully Added Records:</h4>\n                    {addedRecords.length > 0 ? (\n                      <ul>\n                        {addedRecords.map((record, index) => (\n                          <li key={index}>{record}</li>\n                        ))}\n                      </ul>\n                    ) : (\n                      <p>No records added.</p>\n                    )}\n                  </div>\n                  <div className=\"failed-records\">\n                    <h4>Failed to Add Records:</h4>\n                    {failedRecords.length > 0 ? (\n                      <ul>\n                        {failedRecords.map((record, index) => (\n                          <li key={index}>{record}</li>\n                        ))}\n                      </ul>\n                    ) : (\n                      <p>No records failed.</p>\n                    )}\n                  </div>\n                  <div className=\"updated-records\">\n                    <h4>Successfully Updated Records:</h4>\n                    {updatedRecords.length > 0 ? (\n                      <ul>\n                        {updatedRecords.map((record, index) => (\n                          <li key={index}>{record}</li>\n                        ))}\n                      </ul>\n                    ) : (\n                      <p>No records updated.</p>\n                    )}\n                  </div>\n                </div>\n              </div>\n              <button onClick={() => supabase.auth.signOut()}>Sign Out</button>\n            </>\n          ) : (\n            <>\n              <button onClick={() => supabase.auth.signInWithOAuth({\n                provider: 'google',\n                options: {\n                  scopes: 'https://www.googleapis.com/auth/calendar'\n                }\n              })}>\n                Sign In With Google\n              </button>\n            </>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",{"ruleId":"23","severity":1,"message":"24","line":223,"column":16,"nodeType":"25","messageId":"26","endLine":223,"endColumn":34},{"ruleId":"23","severity":1,"message":"27","line":246,"column":16,"nodeType":"25","messageId":"26","endLine":246,"endColumn":36},{"ruleId":"23","severity":1,"message":"28","line":425,"column":10,"nodeType":"25","messageId":"26","endLine":425,"endColumn":15},{"ruleId":"29","severity":1,"message":"30","line":630,"column":6,"nodeType":"31","endLine":630,"endColumn":28,"suggestions":"32"},"no-unused-vars","'lockAirtableRecord' is defined but never used.","Identifier","unusedVar","'unlockAirtableRecord' is defined but never used.","'sleep' is defined but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'calendarInfo', 'rateLimitHit', and 'supabase.auth'. Either include them or remove the dependency array.","ArrayExpression",["33"],{"desc":"34","fix":"35"},"Update the dependencies array to be: [triggerSync, session, calendarInfo, rateLimitHit, supabase.auth]",{"range":"36","text":"37"},[20750,20772],"[triggerSync, session, calendarInfo, rateLimitHit, supabase.auth]"]