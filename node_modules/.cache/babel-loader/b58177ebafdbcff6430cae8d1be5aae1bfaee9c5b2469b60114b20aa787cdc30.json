{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/richardmcgirt/Desktop/Warrenty2-/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _objectSpread = require(\"/Users/richardmcgirt/Desktop/Warrenty2-/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar copyProperty = function copyProperty(to, from, property, ignoreNonConfigurable) {\n  // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n  // `Function#prototype` is non-writable and non-configurable so can never be modified.\n  if (property === 'length' || property === 'prototype') {\n    return;\n  }\n\n  // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n  if (property === 'arguments' || property === 'caller') {\n    return;\n  }\n  var toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n  var fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n    return;\n  }\n  Object.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nvar canCopyProperty = function canCopyProperty(toDescriptor, fromDescriptor) {\n  return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);\n};\nvar changePrototype = function changePrototype(to, from) {\n  var fromPrototype = Object.getPrototypeOf(from);\n  if (fromPrototype === Object.getPrototypeOf(to)) {\n    return;\n  }\n  Object.setPrototypeOf(to, fromPrototype);\n};\nvar wrappedToString = function wrappedToString(withName, fromBody) {\n  return \"/* Wrapped \".concat(withName, \"*/\\n\").concat(fromBody);\n};\nvar toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nvar toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nvar changeToString = function changeToString(to, from, name) {\n  var withName = name === '' ? '' : \"with \".concat(name.trim(), \"() \");\n  var newToString = wrappedToString.bind(null, withName, from.toString());\n  // Ensure `to.toString.toString` is non-enumerable and has the same `same`\n  Object.defineProperty(newToString, 'name', toStringName);\n  Object.defineProperty(to, 'toString', _objectSpread(_objectSpread({}, toStringDescriptor), {}, {\n    value: newToString\n  }));\n};\nvar mimicFn = function mimicFn(to, from) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$ignoreNonConfigu = _ref.ignoreNonConfigurable,\n    ignoreNonConfigurable = _ref$ignoreNonConfigu === void 0 ? false : _ref$ignoreNonConfigu;\n  var name = to.name;\n  var _iterator = _createForOfIteratorHelper(Reflect.ownKeys(from)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var property = _step.value;\n      copyProperty(to, from, property, ignoreNonConfigurable);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  changePrototype(to, from);\n  changeToString(to, from, name);\n  return to;\n};\nmodule.exports = mimicFn;","map":{"version":3,"names":["copyProperty","to","from","property","ignoreNonConfigurable","toDescriptor","Object","getOwnPropertyDescriptor","fromDescriptor","canCopyProperty","defineProperty","undefined","configurable","writable","enumerable","value","changePrototype","fromPrototype","getPrototypeOf","setPrototypeOf","wrappedToString","withName","fromBody","toStringDescriptor","Function","prototype","toStringName","toString","changeToString","name","trim","newToString","bind","mimicFn","Reflect","ownKeys","module","exports"],"sources":["/Users/richardmcgirt/Desktop/Warrenty2-/node_modules/mem/node_modules/mimic-fn/index.js"],"sourcesContent":["'use strict';\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nconst mimicFn = (to, from, {ignoreNonConfigurable = false} = {}) => {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}