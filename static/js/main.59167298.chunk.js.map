{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["isTerminated","Set","async","fetchWithRetry","url","options","retries","arguments","length","undefined","delay","i","_errorData$error","_errorData$error2","response","fetch","ok","json","errorData","error","status","message","includes","console","warn","Promise","res","setTimeout","refreshAccessToken","log","method","headers","Error","data","access_token","localStorage","setItem","Date","now","expires_in","toString","getValidAccessToken","tokenExpiry","parseInt","getItem","accessToken","createGoogleCalendarEvent","event","calendarId","session","provider_token","newEvent","summary","title","description","start","dateTime","toISOString","timeZone","end","location","Authorization","body","JSON","stringify","id","updateAirtableWithGoogleEventIdAndProcessed","airtableRecordId","googleEventId","hasChanges","calendarLink","updateData","fields","GoogleEventId","Processed","CalendarLink","LastUpdated","fetchUnprocessedEventsFromAirtable","today","setHours","todayISO","split","records","map","record","b","processed","streetAddress","city","state","zipCode","filter","Boolean","join","sleep","ms","resolve","deleteGoogleCalendarEvent","eventId","tokenResponse","removeDuplicateEvents","events","_data$items","items","fetchGoogleCalendarEvents","eventMap","Map","duplicateEvents","forEach","eventKey","toLowerCase","trim","date","has","push","set","App","calendarMap","Savannah","Charleston","Greensboro","MyrtleBeach","Wilmington","Grenville","Columbia","Raleigh","useEffect","checkTokenExpiry","interval","setInterval","clearInterval","supabase","useSupabaseClient","useSession","countdown","setCountdown","useState","nextTenMinuteMark","setMinutes","Math","ceil","getMinutes","max","floor","getTimeUntilNextQuarterHour","calendarEvents","setCalendarEvents","Object","fromEntries","entries","_ref2","calendarName","added","failed","noChange","isEventDifferent","airtableEvent","googleEvent","isTitleDifferent","isStartDifferent","isEndDifferent","isDescriptionDifferent","isLocationDifferent","errorResponse","code","updateGoogleCalendarEvent","_originalEvent$start4","_originalEvent$start5","_originalEvent$end3","_originalEvent$end4","_originalEvent$start6","originalResponse","originalEvent","originalStart","originalEnd","originalTimeZone","normalizeToISO","dateStr","normalizedOriginalStart","normalizedOriginalEnd","normalizedNewStart","normalizedNewEnd","updatedEvent","attempt","statusText","fetchAndProcessEvents","updatedCalendarEvents","filteredAirtableEvents","_event$b","replace","googleCalendarEvents","googleEventMap","_event$summary","addedEvents","eventTitle","matchingGoogleEvent","get","calendarError","values","prevEvents","nextSyncTime","currentHour","getHours","timeUntilNextSync","React","createElement","className","seconds","minutes","secs","String","padStart","formatCountdown","onClick","auth","refreshSession","signOut","Fragment","style","display","gridTemplateColumns","gap","_ref3","updated","key","index","eventStart","toLocaleString","eventEnd","isNaN","reportWebVitals","onPerfEntry","Function","then","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","createClient","ReactDOM","createRoot","document","getElementById","render","StrictMode","SessionContextProvider","supabaseClient"],"mappings":"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","file":"static/js/main.59167298.chunk.js","sourcesContent":["\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\n\nimport { useSession, useSupabaseClient} from '@supabase/auth-helpers-react';\nlet isTerminated = false; // Initialize the variable early in the file\nlet processedRecords = new Set(); // Store processed records to prevent duplicates\n\nfunction normalizeDateTime(dateStr) {\n  return new Date(dateStr).toISOString().split(\".\")[0] + \"Z\"; // Removes milliseconds\n}\n\n\nasync function fetchWithRetry(url, options, retries = 3, delay = 10000) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url, options);\n      if (response.ok) return await response.json(); // Return data if successful\n\n      const errorData = await response.json();\n      if (errorData.error?.status === \"PERMISSION_DENIED\" && errorData.error?.message.includes(\"Quota exceeded\")) {\n        console.warn(`Quota exceeded. Retrying in ${delay / 1000} seconds...`);\n        await new Promise(res => setTimeout(res, delay));\n      } else {\n        console.error(\"API request failed:\", errorData);\n        return null;\n      }\n    } catch (error) {\n      console.error(\"Network error during fetch:\", error);\n      await new Promise(res => setTimeout(res, delay));\n    }\n  }\n  console.error(\"Max retries reached. API request failed.\");\n  return null;\n}\n\n\nasync function fetchGoogleCalendarEvents(calendarId) {\n  console.log(`📅 Fetching events for Google Calendar: ${calendarId}`);\n\n  try {\n      let accessToken = await getValidAccessToken();\n      if (!accessToken) {\n          console.error(\"❌ No valid access token available. Attempting to refresh...\");\n          accessToken = await refreshAccessToken();\n      }\n\n      if (!accessToken) {\n          console.error(\"❌ Still no valid access token after refresh. Aborting.\");\n          return;\n      }\n\n      console.log(\"🔑 Using Access Token:\", accessToken);\n\n      const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${new Date().toISOString()}&maxResults=250&orderBy=startTime&singleEvents=true`;\n\n      console.log(`🌍 Calling Google Calendar API: ${url}`);\n\n      const response = await fetch(url, {\n          method: 'GET',\n          headers: { Authorization: `Bearer ${accessToken}` },\n      });\n\n      if (!response.ok) {\n          const errorData = await response.json();\n          console.error('❌ Failed to fetch Google Calendar events:', errorData);\n          return [];\n      }\n\n      const data = await response.json();\n      console.log(`✅ Successfully fetched ${data.items?.length || 0} events.`);\n      return data.items || [];\n\n  } catch (error) {\n      console.error('❌ Error fetching Google Calendar events:', error);\n      return [];\n  }\n}\n\nasync function refreshAccessToken() {\n  try {\n      console.log(\"🔄 Refreshing access token...\");\n\n      const response = await fetch(\"http://localhost:5001/api/refresh-token\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n      });\n\n      if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      if (data.access_token) {\n          console.log(\"✅ New Access Token:\", data.access_token);\n\n          // Store new token & expiry time\n          localStorage.setItem(\"accessToken\", data.access_token);\n          localStorage.setItem(\"tokenExpiry\", (Date.now() + data.expires_in * 1000).toString());\n\n          return data.access_token;\n      } else {\n          throw new Error(\"No access token returned\");\n      }\n  } catch (error) {\n      console.error(\"❌ Failed to refresh token:\", error);\n      return null;\n  }\n}\n\n\nasync function getValidAccessToken() {\n  try {\n      console.log(\"🔄 Checking if token refresh is needed...\");\n      \n      let tokenExpiry = parseInt(localStorage.getItem(\"tokenExpiry\"), 10) || 0;\n      let now = Date.now();\n\n      if (!tokenExpiry || now >= tokenExpiry) {\n          console.warn(\"⚠️ Token expired or missing. Refreshing...\");\n          return await refreshAccessToken();  // Refresh token if expired\n      }\n\n      let accessToken = localStorage.getItem(\"accessToken\");\n      console.log(\"✅ Using stored access token:\", accessToken);\n      return accessToken;\n  } catch (error) {\n      console.error(\"❌ Error getting valid access token:\", error);\n      return null;\n  }\n}\n\n\n\n\nfunction terminateScript() {\n  isTerminated = true;\n  console.log(\"Terminating all processes.\");\n  clearAllTimers();\n}\n\nif (typeof isTerminated !== 'undefined' && isTerminated) {\n  console.log(\"Script is terminated. Skipping further actions.\");\n}\n\n\nasync function createGoogleCalendarEvent(event, calendarId, session) {\n  if (!session || !session.provider_token) {\n    console.error(\"❌ No valid session token found. Attempting to refresh...\");\n    session = { provider_token: await getValidAccessToken() };\n  }\n\n  if (!session.provider_token) {\n    console.error(\"❌ Still no valid access token after refresh. Aborting event creation.\");\n    return null;\n  }\n\n  console.log(\"🔑 Using Access Token in Script:\", session.provider_token);\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n  \n  const newEvent = {\n    summary: event.title,\n    description: event.description || \"No description provided\",\n    start: { dateTime: new Date(event.start).toISOString(), timeZone: \"America/Toronto\" },\n    end: { dateTime: new Date(event.end).toISOString(), timeZone: \"America/Toronto\" },\n    location: event.location || \"No location provided\",\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${session.provider_token}`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(newEvent),\n    });\n\n    const data = await response.json();\n    \n    if (!response.ok) {\n      console.error(\"❌ Error creating Google Calendar event:\", data);\n      return null;\n    }\n\n    console.log(`✅ Event created successfully: \"${event.title}\" (ID: ${data.id})`);\n    return data.id;\n  } catch (error) {\n    console.error(\"❌ Failed to create event:\", error);\n    return null;\n  }\n}\n\n\n\n// Creates a new Google Calendar event\nasync function createGoogleCalendarEvent3(event, calendarId, session) {\n  console.log(`🔑 Using Access Token: ${session.provider_token}`); // Add this line for debugging\n\n  if (isTerminated) {\n    console.log(\"🛑 Script is terminated. Skipping event creation.\");\n    return null;\n  }\n\n  console.log(`🚀 Checking for duplicate event: \"${event.title}\"`);\n  const duplicateEventId = await checkForDuplicateEvent(event, calendarId, session);\n\n  if (duplicateEventId) {\n    console.log(`⚠️ Skipping creation: Event \"${event.title}\" already exists in Google Calendar.`);\n    return duplicateEventId;\n  }\n\n  console.log(`🚀 Creating new Google Calendar event for: \"${event.title}\"...`);\n\n  // ✅ Ensure proper date formatting\n  const startDate = event.start ? new Date(event.start).toISOString() : null;\n  const endDate = event.end ? new Date(event.end).toISOString() : null;\n\n  if (!startDate || !endDate) {\n    console.error(`❌ Invalid start or end date for event \"${event.title}\":`, { startDate, endDate });\n    return null;\n  }\n\n  // ✅ Ensure location is properly defined\n  const location = [\n    event.streetAddress, \n    event.city, \n    event.state, \n    event.zipCode\n  ].filter(Boolean).join(\", \");\n\n// ✅ Log the extracted location before creating the event\nconsole.log(`📌 Location extracted for event \"${event.title}\":`, location);\nconsole.log(\"🔍 Event Object Before Google Calendar Creation:\", event);\n\n\n  // ✅ Create the event object\n  const newEvent = {\n    summary: event.title,\n    description: event.description || \"No description provided\",\n    start: { dateTime: startDate, timeZone: \"America/Toronto\" },\n    end: { dateTime: endDate, timeZone: \"America/Toronto\" },\n    location: location || \"Unknown Location\", // ✅ Ensures proper location formatting\n};\n\n\n  // ✅ Log event details for debugging\n  console.log(\"📝 Event Details:\");\n  console.log(`- Title: ${event.title}`);\n  console.log(`- Description: ${newEvent.description}`);\n  console.log(`- Start Time: ${startDate}`);\n  console.log(`- End Time: ${endDate}`);\n  console.log(`- Location: ${newEvent.location}`);\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n\n  try {\n    const options = {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${session.provider_token}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(newEvent),\n    };\n    \n    const data = await fetchWithRetry(url, options);\n    \n\n    console.log(`✅ Event created successfully: \"${event.title}\" (ID: ${data.id})`);\n    return data.id;\n  } catch (error) {\n    console.error('❌ Error creating Google Calendar event:', error);\n    return null;\n  }\n}\n\n\n\n\nasync function updateAirtableWithGoogleEventIdAndProcessed(airtableRecordId, googleEventId, hasChanges, calendarLink) {\n  if (!hasChanges) {\n    console.log(`No changes found for record ${airtableRecordId}. Skipping update.`);\n    return; // Exit the function if no changes are found\n  }\n\n  console.log(`Updating Airtable record ${airtableRecordId} with Google Event ID: ${googleEventId}, marking as processed, and adding Calendar Link`);\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  const updateData = {\n    fields: {\n      GoogleEventId: googleEventId,\n      Processed: true, // Mark the record as processed to avoid duplicate syncs\n      CalendarLink: calendarLink, // Add the generated Calendar Link here\n      LastUpdated: new Date().toISOString(),\n    },\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    const data = await response.json();\n    if (!response.ok) {\n      console.error('Error updating Airtable:', data.error);\n    } else {\n      console.log('Airtable record successfully updated:', data);\n    }\n  } catch (error) {\n    console.error('Error updating Airtable:', error);\n  }\n}\n\nasync function lockAirtableRecord(airtableRecordId) {\n  console.log(`Locking Airtable record ${airtableRecordId}`);\n  \n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  const updateData = { fields: { Processed: true } };\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    const data = await response.json();\n    if (!response.ok) {\n      console.error(`Error locking record ${airtableRecordId}:`, data);\n    } else {\n      console.log(`Record ${airtableRecordId} locked successfully.`);\n    }\n  } catch (error) {\n    console.error(`Error locking record ${airtableRecordId}:`, error);\n  }\n}\n\nasync function unlockAirtableRecord(airtableRecordId) {\n  console.log(`Unlocking Airtable record ${airtableRecordId}`);\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  \n  // Add a delay to ensure Airtable has time to sync before unlocking\n  await sleep(6000); // 3 seconds delay before unlocking\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ fields: {} }), // Empty body when unlocking\n    });\n\n    const data = await response.json();\n    if (!response.ok) {\n      console.error(`Error unlocking record ${airtableRecordId}:`, data.error || data);\n    } else {\n      console.log(`Record ${airtableRecordId} unlocked successfully.`);\n    }\n  } catch (error) {\n    console.error(`Failed to unlock record ${airtableRecordId}:`, error);\n  }\n}\n\nasync function fetchUnprocessedEventsFromAirtable() {\n  if (isTerminated) {\n    console.log('Script is terminated. Skipping fetch for unprocessed events.');\n    return [];\n  }\n\n  console.log('Fetching unprocessed events from Airtable...');\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  const todayISO = today.toISOString().split(\"T\")[0]; // Extracts YYYY-MM-DD format\n  \n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ?filterByFormula=OR(IS_AFTER({FormattedStartDate}, '${todayISO}'), {FormattedStartDate}='${todayISO}')`;\n  \n  try {\n    const options = {\n      headers: {\n              Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n              'Content-Type': 'application/json',\n            },\n          };\n          \n          const data = await fetchWithRetry(url, options);\n\n          const records = data.records.map((record) => ({\n            id: record.id,\n            title: record.fields['Lot Number and Community/Neighborhood'] || 'No lot number',\n            start: new Date(record.fields['FormattedStartDate']),\n            end: new Date(record.fields['FormattedEndDate']),\n            description: record.fields['Description of Issue'] || '',\n            b: record.fields['b'] || '',\n            processed: record.fields['Processed'] || false,\n            streetAddress: record.fields['Street Address'] || \"\",\n            city: record.fields['City'] || \"\",\n            state: record.fields['State'] || \"\",\n            zipCode: record.fields['Zip Code'] || \"\",\n            location: [\n                record.fields['Street Address'],\n                record.fields['City'],\n                record.fields['State'],\n                record.fields['Zip Code']\n            ].filter(Boolean).join(', ')\n        }));\n        \n        console.log(\"🚀 Processed Airtable records:\", records);\n        \n        console.log(\"Fetched raw Airtable data:\", data.records);\n\n\n      console.log(\"Fetched unprocessed records:\", records);\n      \n      if (records.length === 0) {\n        console.log('No unprocessed events found.');\n        // Do NOT set isTerminated to true, or reset it after a delay\n        setTimeout(() => { isTerminated = false; }, 60000); // Reset after 1 minute\n      }\n      \n      \n      return records;\n  } catch (error) {\n      console.error('Error fetching Airtable events:', error);\n      return [];\n  }\n}\n\nfunction clearAllTimers() {\n  const highestTimeoutId = setTimeout(() => {}, 0);\n  for (let i = 0; i < highestTimeoutId; i++) {\n    clearTimeout(i);\n  }\n  // Also clear intervals\n  const highestIntervalId = setInterval(() => {}, 0);\n  for (let i = 0; i < highestIntervalId; i++) {\n    clearInterval(i);\n  }\n}\n\n\n// Check for duplicate Google Calendar events\nasync function checkForDuplicateEvent(event, calendarId, session) {\n  console.log(`🔍 Checking for duplicate event: \"${event.title}\"`);\n\n  if (!session || !session.provider_token) {\n      console.warn(\"⚠️ No valid session token found. Fetching a new token...\");\n      session = { provider_token: await getValidAccessToken() };\n      if (!session.provider_token) {\n          console.error(\"❌ Failed to retrieve a valid access token. Skipping duplicate check.\");\n          return null;\n      }\n  }\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n  const timeMin = event.start ? new Date(event.start).toISOString() : null;\n  const timeMax = event.end ? new Date(event.end).toISOString() : null;\n\n  if (!timeMin || !timeMax) {\n      console.error(`❌ Invalid start or end date for event \"${event.title}\":`, { timeMin, timeMax });\n      return null;\n  }\n\n  try {\n      console.log(`🌍 Fetching events from Google Calendar between ${timeMin} and ${timeMax}...`);\n\n      const response = await fetch(\n          `${url}?timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true`,\n          {\n              headers: {\n                  Authorization: `Bearer ${session.provider_token}`,\n              },\n          }\n      );\n\n      if (!response.ok) {\n          const errorData = await response.json();\n          console.error(\"❌ Failed to fetch events from Google Calendar:\", errorData);\n          return null;\n      }\n\n      const data = await response.json();\n      console.log(`📌 Retrieved ${data.items?.length || 0} events for duplicate check.`);\n\n      if (!data.items || data.items.length === 0) {\n          console.log(`✅ No duplicate event found for \"${event.title}\".`);\n          return null;\n      }\n\n      // Normalize event data for better duplicate detection\n      const normalizeText = (text) => text.trim().replace(/\\s+/g, \" \").toLowerCase();\n      const duplicateEvent = data.items.find((existingEvent) => {\n          if (!existingEvent.start?.dateTime || !existingEvent.end?.dateTime) {\n              console.warn(`⚠️ Skipping event due to missing start or end time:`, existingEvent);\n              return false;\n          }\n\n          const googleStart = normalizeDateTime(existingEvent.start.dateTime);\n          const googleEnd = normalizeDateTime(existingEvent.end.dateTime);\n\n          return (\n              normalizeText(existingEvent.summary) === normalizeText(event.title) &&\n              googleStart === timeMin &&\n              googleEnd === timeMax\n          );\n      });\n\n      if (duplicateEvent) {\n          console.log(`🚨 Duplicate event found: \"${event.title}\", ID: ${duplicateEvent.id}`);\n          return duplicateEvent.id;\n      }\n\n      console.log(`✅ No duplicate event found for: \"${event.title}\".`);\n      return null;\n  } catch (error) {\n      console.error(\"❌ Error checking for duplicate events:\", error);\n      return null;\n  }\n}\n\n\n\n\n\n\n\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nasync function populateGoogleCalendarWithAirtableRecords(\n  calendarId,\n  calendarName,\n  session,\n  setAddedRecords,\n  setFailedRecords,\n  setNoChangeRecords,\n  setAllRecordsProcessed\n) {\n  console.log(`Starting to populate Google Calendar \"${calendarName}\" with Airtable records...`);\n\n  if (isTerminated) {\n    console.log('🛑 Script is terminated. Skipping population.');\n    return;\n  }\n\n  const airtableEvents = await fetchUnprocessedEventsFromAirtable();\n  if (isTerminated) {\n    console.log(\"🛑 Script was terminated after fetching. Stopping processing.\");\n    return;\n  }\n\n  const totalFetchedRecords = airtableEvents.length;\n  if (totalFetchedRecords === 0) {\n    console.log(`✅ No unprocessed events to sync for calendar \"${calendarName}\".`);\n    return;\n  }\n\n  let createdEventsCount = 0;\n  const added = [];\n  const failed = [];\n  const noChange = [];\n  const processedRecordIds = new Set();\n\n  for (const event of airtableEvents) {\n    if (isTerminated) {\n      console.log(\"🛑 Script was terminated. Stopping event processing.\");\n      return;\n    }\n\n    if (event.googleEventId || event.processed) {\n      console.log(`Skipping event \"${event.title}\" - GoogleEventId or Processed status already set.`);\n      noChange.push(event.title);\n      processedRecordIds.add(event.id);\n      continue;\n    }\n\n    try {\n      await lockAirtableRecord(event.id);\n      let googleEventId = await checkForDuplicateEvent(event, calendarId, session);\n\n      if (isTerminated) {\n        console.log(\"🛑 Termination detected. Skipping event creation.\");\n        return;\n      }\n\n      if (googleEventId) {\n        const googleEvent = await getGoogleCalendarEvent(googleEventId, calendarId, session);\n\n        // Skip updates if no changes exist\n        if (!isEventDifferent(event, googleEvent)) {\n          console.log(`✅ No changes detected for event \"${event.title}\". Skipping update.`);\n          noChange.push(event.title);\n          processedRecordIds.add(event.id);\n          await unlockAirtableRecord(event.id);\n          continue;\n        }\n\n        console.log(`⚠️ Updating event \"${event.title}\" as it has changed.`);\n        await updateGoogleCalendarEvent(\n          googleEventId,\n          event.title,\n          event.start,\n          event.end,\n          calendarId,\n          session\n        );\n        await updateAirtableWithGoogleEventIdAndProcessed(event.id, googleEventId, true);\n      } else {\n        console.log(`🆕 Creating new event: ${event.title}`);\n        googleEventId = await createGoogleCalendarEvent(event, calendarId, session);\n        if (googleEventId) {\n          await updateAirtableWithGoogleEventIdAndProcessed(event.id, googleEventId, true);\n          added.push(event.title);\n          createdEventsCount++;\n        } else {\n          failed.push(event.title);\n        }\n      }\n\n      processedRecordIds.add(event.id);\n    } catch (error) {\n      console.error(`❌ Error processing event \"${event.title}\":`, error);\n      failed.push(event.title);\n    }\n\n    await unlockAirtableRecord(event.id);\n    await sleep(12000); // Delay to avoid hitting rate limits\n  }\n\n  if (isTerminated) {\n    console.log(\"🛑 All records processed but script was terminated.\");\n    return;\n  }\n\n  setAddedRecords((prev) => [...prev, ...added]);\n  setFailedRecords((prev) => [...prev, ...failed]);\n  setNoChangeRecords(noChange);\n\n  console.log(`✅ Total number of events created: ${createdEventsCount}`);\n  console.log(`✅ Total number of records processed for calendar \"${calendarName}\": ${processedRecordIds.size}`);\n}\n\nfunction isEventDifferent(airtableEvent, googleEvent) {\n  if (!airtableEvent || !googleEvent || !googleEvent.start || !googleEvent.end) {\n      console.error('❌ Missing event data:', { airtableEvent, googleEvent });\n      return true; \n  }\n\n  const normalizeText = (text) => (text || \"\").trim().toLowerCase();\n  \n  return (\n      normalizeText(airtableEvent.title) !== normalizeText(googleEvent.summary) ||\n      normalizeText(airtableEvent.location) !== normalizeText(googleEvent.location) ||\n      new Date(airtableEvent.start).toISOString() !== googleEvent.start.dateTime ||\n      new Date(airtableEvent.end).toISOString() !== googleEvent.end.dateTime\n  );\n\n}\n\n\n\nasync function updateGoogleCalendarEvent(eventId, title, start, end, calendarId) {\n  console.log(`🔄 Updating event: ${title}`);\n\n  // ✅ Get a fresh valid access token\n  const accessToken = await getValidAccessToken();\n  if (!accessToken) {\n      console.error(\"❌ No valid access token available. Skipping update.\");\n      return;\n  }\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n\n  try {\n      // Fetch the original event details before updating\n      const originalResponse = await fetch(url, {\n          method: 'GET',\n          headers: {\n              Authorization: `Bearer ${accessToken}`,\n              'Content-Type': 'application/json',\n          },\n      });\n\n      if (!originalResponse.ok) {\n          const errorData = await originalResponse.json();\n          console.error('❌ Failed to fetch original Google Calendar event:', errorData);\n          return;\n      }\n\n      const originalEvent = await originalResponse.json();\n      const originalStart = originalEvent.start?.dateTime || originalEvent.start?.date;\n      const originalEnd = originalEvent.end?.dateTime || originalEvent.end?.date;\n      const originalTimeZone = originalEvent.start?.timeZone || \"America/New_York\";\n\n      // Convert to strict ISO format\n      const normalizeToISO = (dateStr) => (dateStr ? new Date(dateStr).toISOString() : null);\n      const normalizedOriginalStart = normalizeToISO(originalStart);\n      const normalizedOriginalEnd = normalizeToISO(originalEnd);\n      const normalizedNewStart = normalizeToISO(start);\n      const normalizedNewEnd = normalizeToISO(end);\n\n      console.log(\"🔵 Original Event Data:\", {\n          title: originalEvent.summary,\n          start: normalizedOriginalStart,\n          end: normalizedOriginalEnd,\n          timeZone: originalTimeZone,\n      });\n\n      console.log(\"🟡 Updated Event Data:\", {\n          summary: title,\n          start: normalizedNewStart,\n          end: normalizedNewEnd,\n          timeZone: originalTimeZone,\n      });\n\n      // ✅ Skip update if nothing has changed\n      if (normalizedNewStart === normalizedOriginalStart && normalizedNewEnd === normalizedOriginalEnd) {\n          console.log(\"✅ No change detected. Skipping update.\");\n          return;\n      }\n\n      console.log(\"⚠️ Changes detected. Updating event...\");\n\n      // Construct updated event object\n      const updatedEvent = {\n          summary: title,\n          start: { dateTime: normalizedNewStart, timeZone: originalTimeZone },\n          end: { dateTime: normalizedNewEnd, timeZone: originalTimeZone },\n      };\n\n      const updateResponse = await fetch(url, {\n          method: 'PUT',\n          headers: {\n              Authorization: `Bearer ${accessToken}`,\n              'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(updatedEvent),\n      });\n\n      if (!updateResponse.ok) {\n          console.error(\"❌ Failed to update event:\", await updateResponse.json());\n          return;\n      }\n\n      console.log(`✅ Event updated successfully: ${title}`);\n  } catch (error) {\n      console.error('❌ Error updating event:', error);\n  }\n}\n\n\n\nasync function getGoogleCalendarEvent(eventId, calendarId, session) {\n  // Fetch the token from the backend\n  const tokenResponse = await fetch('http://localhost:5001/api/tokens');\n  \n  if (!tokenResponse.ok) {\n    console.error(\"Failed to fetch token\");\n    return null;\n  }\n\n  const tokens = await tokenResponse.json();\n  const accessToken = tokens.access_token;\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n  try {\n    const response = await fetch(url, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`Failed to fetch event from Google Calendar: ${eventId}`);\n      return null;\n    }\n\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error fetching Google Calendar event:', error);\n    return null;\n  }\n}\n\n\n\nasync function deleteGoogleCalendarEvent(eventId, calendarId, session) {\n  // Fetch the token from the backend\n  const tokenResponse = await fetch('http://localhost:5001/api/tokens');\n  \n  if (!tokenResponse.ok) {\n    console.error(\"Failed to fetch token\");\n    return false;\n  }\n\n  const tokens = await tokenResponse.json();\n  const accessToken = tokens.access_token;\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'DELETE',\n      headers: {\n        Authorization: `Bearer ${accessToken}`,  // Use the fetched access token\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      const data = await response.json();\n      console.error('Failed to delete Google Calendar event:', data);\n      return false;\n    }\n\n    console.log('Google Calendar event deleted successfully:', eventId);\n    return true;\n  } catch (error) {\n    console.error('Error deleting Google Calendar event:', error);\n    return false;\n  }\n}\n\n\nfunction CalendarSection({\n  calendarId,\n  calendarName,\n  session,\n  signOut,\n  setAddedRecords,\n  setFailedRecords,\n  setNoChangeRecords,\n    triggerSync,\n  setTriggerSync,\n  handleSyncNow,  // Add the handleSyncNow prop here\n  allRecordsProcessed,  // Destructure this prop\n  setAllRecordsProcessed  // Destructure this prop\n}) {\n  const [lastSyncTime, setLastSyncTime] = useState(null);\n  const [progress, setProgress] = useState(0);\n  const [manualSyncComplete, setManualSyncComplete] = useState(false); // Track manual sync completion\n\n  useEffect(() => {\n    const syncEvents = async () => {\n      // Exit if all records are processed\n      if (allRecordsProcessed) {\n        console.log('All records have been processed. Skipping further sync attempts.');\n        terminateScript(); // Terminate the script before returning\n        return;  // Exit the function after terminating\n      }\n  \n \n  \n      console.log('Attempting to sync events...');\n  \n      if (session && triggerSync) {\n        setProgress(0);\n  \n        if (!session.provider_token) {\n          console.error('No valid session token found. Logging out.');\n          signOut();\n          return;\n        }\n  \n        try {\n          // Sync the events with Google Calendar\n          await populateGoogleCalendarWithAirtableRecords(\n            calendarId,\n            calendarName,\n            session,\n            setAddedRecords,\n            setFailedRecords,\n            setNoChangeRecords,\n            setAllRecordsProcessed\n          );\n  \n          console.log(`Finished syncing events to Google Calendar \"${calendarName}\"`);\n  \n          // After syncing, check for duplicates\n          await removeDuplicateEvents();\n  \n          // Set the last sync time and other status updates\n          setLastSyncTime(new Date());\n          setTriggerSync(false);\n          setManualSyncComplete(true);  // Mark manual sync as complete\n  \n        } catch (error) {\n          console.error(`Error syncing Airtable to Google Calendar \"${calendarName}\":`, error);\n        }\n      }\n    };\n  \n    // Only proceed if manual sync is triggered\n    if (triggerSync) {\n      console.log(`Manual sync triggered for calendar: ${calendarName}`);\n      syncEvents(); // Call the async syncEvents function\n    }\n  \n  }, [\n    session, // React hook dependencies\n    signOut,\n    calendarId,\n    calendarName,\n    setAddedRecords,\n    setFailedRecords,\n    setNoChangeRecords,\n    setAllRecordsProcessed,\n    triggerSync, // Trigger sync when this changes\n    setTriggerSync,\n    allRecordsProcessed, // Terminate if all records are processed\n  ]);\n\n  // After syncing Google Calendar\n  useEffect(() => {\n    if (manualSyncComplete) {\n      console.log(\"Manual sync complete. Stopping further checks.\");\n      return; // Terminate further event checks after sync\n    }\n\n    // Continue with other operations if needed\n  }, [manualSyncComplete]); // Dependency on manual sync completion\n\n  return (\n    <div className=\"calendar-item\">\n      <h2>{calendarName}</h2>\n\n      {lastSyncTime && <p>Last sync: {lastSyncTime.toLocaleString()}</p>}\n      {progress > 0 && <p>Sync progress: {progress.toFixed(0)}%</p>}\n  \n    \n  \n  <button onClick={handleSyncNow}>Sync Now</button>\n\n\n{allRecordsProcessed && (\n  <p>All records have been processed. No further syncs are required.</p>\n)}\n    </div>\n  );\n}\n\nasync function removeDuplicateEvents(calendarId, session) {\n  if (isTerminated) {\n    console.log(\"🛑 Script is terminated. Skipping duplicate removal.\");\n    return;\n  }\n\n  console.log(`Checking for duplicate events in calendar: ${calendarId}...`);\n\n  try {\n    const events = await fetchGoogleCalendarEvents(calendarId, session);\n    if (isTerminated) {\n      console.log(\"🛑 Script was terminated after fetching events. Stopping processing.\");\n      return;\n    }\n\n    if (!events || events.length === 0) {\n      console.log(\"No events found in calendar.\");\n      return;\n    }\n\n    const eventMap = new Map();\n    const duplicateEvents = [];\n\n    events.forEach(event => {\n      if (isTerminated) {\n        console.log(\"🛑 Termination detected during duplicate search.\");\n        return;\n      }\n      const eventKey = `${event.summary.toLowerCase().trim()}_${new Date(event.start.dateTime || event.start.date).toISOString()}`;\n\n      if (eventMap.has(eventKey)) {\n        duplicateEvents.push(event);\n      } else {\n        eventMap.set(eventKey, event);\n      }\n    });\n\n    for (const event of duplicateEvents) {\n      if (isTerminated) {\n        console.log(\"🛑 Termination detected. Stopping deletion process.\");\n        return;\n      }\n      await deleteGoogleCalendarEvent(event.id, calendarId, session);\n      console.log(`🗑️ Deleted duplicate event: ${event.summary} (ID: ${event.id})`);\n    }\n  } catch (error) {\n    console.error(`Error removing duplicate events for calendar ID \"${calendarId}\":`, error);\n  }\n}\n\n\n\n\nfunction formatCountdown(seconds) {\n  const minutes = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;\n}\n\nfunction App() {\n  const calendarMap = {\n    Savannah: 'c_ebe1fcbce1be361c641591a6c389d4311df7a97961af0020c889686ae059d20a@group.calendar.google.com',\n    Charleston: 'c_d113e252e0e5c8cfbf17a13149707a30d3c0fbeeff1baaac7a46940c2cc448ca@group.calendar.google.com',\n    Greensboro: 'c_03867438b82e5dfd8d4d3b6096c8eb1c715425fa012054cc95f8dea7ef41c79b@group.calendar.google.com',\n    MyrtleBeach: 'c_ad562073f4db2c47279af5aa40e53fc2641b12ad2497ccd925feb220a0f1abee@group.calendar.google.com',\n    Wilmington: 'c_45db4e963c3363676038697855d7aacfd1075da441f9308e44714768d4a4f8de@group.calendar.google.com',\n   Grenville: 'c_0476130ac741b9c58b404c737a8068a8b1b06ba1de2a84cff08c5d15ced54edf@group.calendar.google.com',\n   Columbia: 'c_df033dd6c81bb3cbb5c6fdfd58dd2931e145e061b8a04ea0c13c79963cb6d515@group.calendar.google.com',\n       Raleigh: 'warranty@vanirinstalledsales.com',\n  };\n\n  // ✅ Automatically refresh token every 55 minutes\nuseEffect(() => {\n  const checkTokenExpiry = async () => {\n      let tokenExpiry = parseInt(localStorage.getItem(\"tokenExpiry\"), 10) || 0;\n      let now = Date.now();\n\n      if (!tokenExpiry || now >= tokenExpiry) {\n          console.warn(\"⚠️ Token expired or missing. Refreshing...\");\n          await getValidAccessToken();\n      } else {\n          console.log(\"✅ Token is still valid.\");\n      }\n  };\n\n  checkTokenExpiry();\n  \n  // Refresh token every 55 minutes (3300 seconds)\n  const interval = setInterval(checkTokenExpiry, 55 * 60 * 1000);\n\n  return () => clearInterval(interval);\n}, []);\n\n\n  function getTimeUntilNextQuarterHour() {\n    const now = new Date();\n    const nextTenMinuteMark = new Date(now);\n    \n    // Calculate the next 10-minute interval from the beginning of the hour\n    nextTenMinuteMark.setMinutes(Math.ceil(now.getMinutes() / 10) * 10, 0, 0);\n\n    // If we're already at the next 10-minute mark, move to the next one\n    if (nextTenMinuteMark <= now) {\n        nextTenMinuteMark.setMinutes(nextTenMinuteMark.getMinutes() + 10);\n    }\n\n    return Math.max(0, Math.floor((nextTenMinuteMark - now) / 1000)); // Return remaining time in seconds\n}\n\n  const supabase = useSupabaseClient();\n  const session = useSession();\n  const [countdown, setCountdown] = useState(getTimeUntilNextQuarterHour());\n  const [calendarEvents, setCalendarEvents] = useState(\n    Object.fromEntries(\n      Object.entries(calendarMap).map(([calendarName]) => [\n        calendarName,\n        { added: [], failed: [], noChange: [] },\n      ])\n    )\n  );\n\n\n\n  function isEventDifferent(airtableEvent, googleEvent) {\n    const isTitleDifferent = airtableEvent.title !== googleEvent.summary;\n    const isStartDifferent = new Date(airtableEvent.start).toISOString() !== googleEvent.start.dateTime;\n    const isEndDifferent = new Date(airtableEvent.end).toISOString() !== googleEvent.end.dateTime;\n    const isDescriptionDifferent = (airtableEvent.description || '') !== (googleEvent.description || '');\n    const isLocationDifferent = (airtableEvent.location || '') !== (googleEvent.location || '');\n  \n    return isTitleDifferent || isStartDifferent || isEndDifferent || isDescriptionDifferent || isLocationDifferent;\n  }\n  \n  \n  async function fetchGoogleCalendarEvents(calendarId) {\n    let accessToken = await getValidAccessToken(); // Get a valid token from storage or refresh\n\n    if (!accessToken) {\n        console.error(\"❌ No valid access token available. Aborting fetch.\");\n        return [];\n    }\n\n    console.log(\"📅 Fetching Google Calendar events with token:\", accessToken);\n\n    try {\n        const response = await fetch(\n            `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${new Date().toISOString()}&maxResults=250&orderBy=startTime&singleEvents=true`,\n            {\n                method: \"GET\",\n                headers: {\n                    \"Authorization\": `Bearer ${accessToken}`,\n                    \"Content-Type\": \"application/json\",\n                },\n            }\n        );\n\n        if (!response.ok) {\n            const errorResponse = await response.json();\n\n            if (errorResponse.error.code === 401) {\n                console.warn(\"🔄 Access token expired. Attempting to refresh...\");\n\n                // Refresh the token and retry once\n                const newAccessToken = await refreshAccessToken();\n                if (newAccessToken) {\n                    console.log(\"🔄 Retrying event fetch with new token...\");\n                    return await fetchGoogleCalendarEvents(calendarId); // Recursive retry\n                } else {\n                    console.error(\"❌ Failed to refresh token. User may need to re-authenticate.\");\n                    return [];\n                }\n            }\n\n            console.error(\"❌ Google Calendar API Error:\", errorResponse);\n            throw new Error(errorResponse.error.message);\n        }\n\n        const data = await response.json();\n        console.log(`✅ Successfully fetched ${data.items.length} events.`);\n        return data.items || []; // Ensure an empty array is returned if no events exist\n    } catch (error) {\n        console.error(\"❌ Failed to fetch Google Calendar events:\", error.message);\n        return [];\n    }\n}\n\n\n\n  \n  \n\n  \n  \n  \n  \n  async function updateGoogleCalendarEvent(eventId, title, start, end, calendarId) {\n    try {\n        const accessToken = await getValidAccessToken();\n        if (!accessToken) {\n            console.error(\"❌ No valid access token available.\");\n            return;\n        }\n\n        const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n\n        // 🟢 Fetch the original event before updating\n        const originalResponse = await fetch(url, {\n            method: 'GET',\n            headers: {\n                Authorization: `Bearer ${accessToken}`,\n                'Content-Type': 'application/json',\n            },\n        });\n\n        if (!originalResponse.ok) {\n            console.error(\"❌ Failed to fetch original Google Calendar event.\");\n            return;\n        }\n\n        const originalEvent = await originalResponse.json();\n        const originalStart = originalEvent.start?.dateTime || originalEvent.start?.date;\n        const originalEnd = originalEvent.end?.dateTime || originalEvent.end?.date;\n        const originalTimeZone = originalEvent.start?.timeZone || \"America/New_York\"; // Default to EST\n\n        // ✅ Normalize all times to strict ISO format\n        const normalizeToISO = (dateStr) => dateStr ? new Date(dateStr).toISOString() : null;\n        const normalizedOriginalStart = normalizeToISO(originalStart);\n        const normalizedOriginalEnd = normalizeToISO(originalEnd);\n        const normalizedNewStart = normalizeToISO(start);\n        const normalizedNewEnd = normalizeToISO(end);\n\n        console.log(\"🔵 Original Event (Before Update):\", {\n            summary: originalEvent.summary,\n            start: normalizedOriginalStart,\n            end: normalizedOriginalEnd,\n            timeZone: originalTimeZone,\n        });\n\n        console.log(\"🟡 Updated Event Data (Before Sending):\", {\n            summary: title,\n            start: normalizedNewStart,\n            end: normalizedNewEnd,\n            timeZone: originalTimeZone,\n        });\n\n        // 🛑 Prevent unnecessary updates if times are unchanged\n        if (normalizedNewStart === normalizedOriginalStart && normalizedNewEnd === normalizedOriginalEnd) {\n            console.log(\"✅ No changes detected. Skipping update.\");\n            return;\n        }\n\n        console.log(\"⚠️ Change detected. Updating event...\");\n\n        // 🔄 Prepare the updated event payload\n        const updatedEvent = {\n            summary: title,\n            start: { dateTime: normalizedNewStart, timeZone: originalTimeZone },\n            end: { dateTime: normalizedNewEnd, timeZone: originalTimeZone },\n        };\n\n        const options = {\n            method: 'PATCH',\n            headers: {\n                Authorization: `Bearer ${accessToken}`,\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(updatedEvent),\n        };\n\n        // ✅ Handle API rate limits by retrying on failure\n        const apiResponse = await fetchWithRetry(url, options);\n        if (!apiResponse) {\n            console.error(\"❌ Failed to update Google Calendar event after retries.\");\n            return;\n        }\n\n        console.log(`✅ Successfully updated event: ${title}`);\n    } catch (error) {\n        console.error(\"❌ Error updating Google Calendar event:\", error);\n    }\n}\nasync function fetchWithRetry(url, options, retries = 3, delay = 2000) {\n  for (let attempt = 1; attempt <= retries; attempt++) {\n      try {\n          const response = await fetch(url, options);\n          if (response.ok) return response;\n\n          console.warn(`⚠️ API call failed (Attempt ${attempt}/${retries}): ${response.statusText}`);\n          if (response.status === 429) {\n              console.log(\"⏳ Rate limit hit. Retrying after delay...\");\n              await new Promise(resolve => setTimeout(resolve, delay));\n          } else {\n              return null; // Stop retrying on other errors\n          }\n      } catch (error) {\n          console.error(\"❌ API request error:\", error);\n      }\n  }\n  return null;\n}\n\n\nuseEffect(() => {\n    const getTimeUntilNextQuarterHour = () => {\n        const now = new Date();\n        const nextSyncTime = new Date(now);\n\n        // Calculate the next 10-minute interval from the beginning of the hour\n        nextSyncTime.setMinutes(Math.ceil(now.getMinutes() / 10) * 10, 0, 0);\n\n        // If we're already at the next 10-minute mark, move to the next one\n        if (nextSyncTime <= now) {\n            nextSyncTime.setMinutes(nextSyncTime.getMinutes() + 10);\n        }\n\n        return Math.max(0, Math.floor((nextSyncTime - now) / 1000)); // Return remaining time in seconds\n    };\n\n    const interval = setInterval(async () => {\n        const currentHour = new Date().getHours();\n        \n        if (currentHour >= 7 && currentHour <= 17) {\n            const timeUntilNextSync = getTimeUntilNextQuarterHour();\n            setCountdown(timeUntilNextSync);\n\n            if (timeUntilNextSync === 0) {\n                console.log(\"⏳ Checking if token needs refresh...\");\n                \n                let accessToken = await getValidAccessToken();\n                if (!accessToken) {\n                    console.error(\"❌ No valid token available. Skipping sync.\");\n                    return;\n                }\n\n                console.log(\"🔄 Running event sync...\");\n                await fetchAndProcessEvents();\n\n                setCountdown(getTimeUntilNextQuarterHour()); // Reset countdown after sync\n            }\n        }\n    }, 1000); // Check every second to determine when to sync\n\n    return () => clearInterval(interval);\n}, [session]); // Depend on session to ensure proper reactivity\n\n  \n\nasync function handleLogin() {\n  try {\n      const { data, error } = await supabase.auth.signInWithOAuth({\n          provider: 'google',\n          options: {\n              scopes: 'https://www.googleapis.com/auth/calendar',\n              redirectTo: window.location.origin, // Redirect back to app after login\n          },\n      });\n\n      if (error) throw error;\n\n      console.log('✅ Supabase Session:', data.session);\n\n      if (data.session) {\n          handleAuthSuccess(data.session);  // ✅ Now using the function to handle token storage\n      }\n  } catch (error) {\n      console.error('❌ Error during login:', error);\n  }\n}\n\n\nasync function saveTokensToBackend(tokens) {\n  try {\n      const response = await fetch(\"http://localhost:5001/save-tokens\", {\n          method: \"POST\",\n          headers: {\n              \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify(tokens),\n      });\n\n      if (!response.ok) {\n          throw new Error(\"Failed to save tokens\");\n      }\n\n      console.log(\"✅ Tokens successfully sent to the backend.\");\n  } catch (error) {\n      console.error(\"❌ Error saving tokens:\", error);\n  }\n}\n\nasync function handleAuthSuccess(session) {\n  console.log(\"🔑 Tokens received:\", session);\n\n  if (!session?.provider_token) {\n      console.error(\"❌ No access token found.\");\n      return;\n  }\n\n  const tokens = {\n      access_token: session.provider_token,\n      refresh_token: session.refresh_token,  // Ensure this exists, or persist it from backend\n      expires_in: session.expires_in || 3600,\n      token_type: \"Bearer\",\n  };\n\n  // ✅ Send tokens to backend for storage\n  await saveTokensToBackend(tokens);\n}\n\n\n\n  \n  const handleLogout = async () => {\n    try {\n      const { error } = await supabase.auth.refreshSession();\n      if (error) {\n        console.error('Error refreshing session:', error);\n      }\n      await supabase.auth.signOut();\n      console.log('User logged out successfully.');\n    } catch (error) {\n      console.error('Error during logout:', error);\n    }\n  };\n  \n\n  async function fetchAndProcessEvents() {\n    try {\n        console.log(\"🚀 Fetching and processing events for all calendars...\");\n\n        // ✅ Retrieve a valid access token ONCE to avoid redundant refreshes\n        let accessToken = await getValidAccessToken();\n        if (!accessToken) {\n            console.error(\"❌ No valid access token available. Aborting.\");\n            return;\n        }\n\n        let allCalendarsProcessed = true;\n        let updatedCalendarEvents = {};\n\n        for (const [calendarName, calendarId] of Object.entries(calendarMap)) {\n            console.log(`📅 Processing events for calendar: ${calendarName}`);\n\n            try {\n                // ✅ Fetch and filter Airtable events for this specific calendar\n                const airtableEvents = await fetchUnprocessedEventsFromAirtable();\n                const filteredAirtableEvents = airtableEvents.filter(\n                    (event) => event.b?.toLowerCase().trim().replace(/\\s+/g, \"\") === calendarName.toLowerCase().trim()\n                );\n\n                if (filteredAirtableEvents.length === 0) {\n                    console.log(`✅ No unprocessed events found for ${calendarName}. Skipping.`);\n                    continue;\n                }\n\n                console.log(`📊 Filtered ${filteredAirtableEvents.length} events from Airtable for calendar: ${calendarName}`);\n                \n                // ✅ Fetch events from Google Calendar (only once per calendar)\n                const googleCalendarEvents = await fetchGoogleCalendarEvents(calendarId);\n                console.log(`📊 Fetched ${googleCalendarEvents.length} events from Google Calendar: ${calendarName}`);\n\n                const googleEventMap = new Map();\n                googleCalendarEvents.forEach((event) => {\n                    googleEventMap.set(event.summary?.toLowerCase().trim(), event);\n                });\n\n                let addedEvents = [];\n\n                for (const airtableEvent of filteredAirtableEvents) {\n                    if (!airtableEvent.start || !airtableEvent.end) {\n                        console.error(`❌ Skipping event \"${airtableEvent.title}\" due to missing start or end date.`);\n                        continue;\n                    }\n\n                    const eventTitle = airtableEvent.title.toLowerCase().trim();\n                    const matchingGoogleEvent = googleEventMap.get(eventTitle);\n\n                    if (matchingGoogleEvent) {\n                        if (isEventDifferent(airtableEvent, matchingGoogleEvent)) {\n                            console.log(`🔄 Updating event: ${airtableEvent.title}`);\n                            await updateGoogleCalendarEvent(\n                                matchingGoogleEvent.id,\n                                airtableEvent.title,\n                                airtableEvent.start,\n                                airtableEvent.end,\n                                calendarId,\n                                accessToken\n                            );\n                        } else {\n                            console.log(`✅ No changes detected for event: ${airtableEvent.title}, skipping update.`);\n                        }\n                    } else {\n                        console.log(`🆕 Creating new event: ${airtableEvent.title}`);\n                        const googleEventId = await createGoogleCalendarEvent(airtableEvent, calendarId, accessToken);\n                        if (googleEventId) {\n                            await updateAirtableWithGoogleEventIdAndProcessed(airtableEvent.id, googleEventId, true);\n                            console.log(`✅ New event created and linked: ${airtableEvent.title}`);\n                            addedEvents.push({\n                                title: airtableEvent.title,\n                                start: airtableEvent.start,\n                                end: airtableEvent.end\n                            });\n                        }\n                    }\n                }\n\n                updatedCalendarEvents[calendarName] = { added: addedEvents };\n\n                console.log(`✅ Finished processing events for calendar: ${calendarName}`);\n                await sleep(5000);\n            } catch (calendarError) {\n                console.error(`❌ Error processing events for calendar \"${calendarName}\":`, calendarError);\n            }\n        }\n\n        // ✅ Remove duplicate events AFTER processing all calendars\n        for (const calendarId of Object.values(calendarMap)) {\n            try {\n                await removeDuplicateEvents(calendarId, accessToken);\n            } catch (error) {\n                console.error(`❌ Error removing duplicate events for calendar ID \"${calendarId}\":`, error);\n            }\n        }\n\n        // ✅ Update state after processing all calendars\n        setCalendarEvents((prevEvents) => ({\n            ...prevEvents,\n            ...updatedCalendarEvents\n        }));\n\n        console.log(\"✅ All events processed for all calendars.\");\n    } catch (error) {\n        console.error(\"❌ Fatal error in fetchAndProcessEvents():\", error);\n    }\n}\n\n\n\n\n\n\n\n\nreturn (\n  <div className=\"App\">\n    <h1>Google Calendar Sync</h1>\n    \n    <p>Next sync in: {formatCountdown(countdown)}</p>\n    {!session ? (\n                <button onClick={getValidAccessToken}>Sign in with Google</button>\n              ) : (\n      <button onClick={handleLogout}>Logout</button>\n    )}\n    {session && (\n      <>\n        <button onClick={fetchAndProcessEvents}>Sync Now</button>\n        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '20px' }}>\n          {Object.entries(calendarEvents).map(([calendarName, events]) => {\n            const added = events?.added || [];\n            const updated = events?.updated || [];\n\n            return (\n              <div key={calendarName} className=\"calendar-section\">\n              <h2>{calendarName}</h2>\n            \n              {added.length > 0 && (\n                <>\n                  <h3>New Events</h3>\n                  <ul>\n                    {added.map((event, index) => {\n                      // Ensure proper date conversion\n                      const eventStart = event.start ? new Date(event.start).toLocaleString() : \"Invalid Date\";\n                      const eventEnd = event.end ? new Date(event.end).toLocaleString() : \"Invalid Date\";\n            \n                      return (\n                        <li key={index}>\n                          <strong>{event.title}</strong> <br />\n                          <span>Start: {isNaN(new Date(event.start)) ? \"Invalid Date\" : eventStart}</span> <br />\n                          <span>End: {isNaN(new Date(event.end)) ? \"Invalid Date\" : eventEnd}</span>\n                        </li>\n                      );\n                    })}\n                  </ul>\n                </>\n              )}\n            \n              {updated.length > 0 && (\n                <>\n                  <h3>Updated Events</h3>\n                  <ul>\n                    {updated.map((event, index) => {\n                      const eventStart = event.start ? new Date(event.start).toLocaleString() : \"Invalid Date\";\n                      const eventEnd = event.end ? new Date(event.end).toLocaleString() : \"Invalid Date\";\n            \n                      return (\n                        <li key={index}>\n                          <strong>{event.title}</strong> <br />\n                          <span>Start: {isNaN(new Date(event.start)) ? \"Invalid Date\" : eventStart}</span> <br />\n                          <span>End: {isNaN(new Date(event.end)) ? \"Invalid Date\" : eventEnd}</span>\n                        </li>\n                      );\n                    })}\n                  </ul>\n                </>\n              )}\n            \n              {added.length === 0 && updated.length === 0 && <p>No new or updated events.</p>}\n            </div>\n            \n            \n            );\n          })}\n        </div>\n      </>\n    )}\n  </div>\n);\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { createClient } from '@supabase/supabase-js';\nimport { SessionContextProvider } from '@supabase/auth-helpers-react';\n\nconst supabase = createClient(\n  \"https://uesmvtbhivtxfazdhoed.supabase.co\",\n  \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVlc212dGJoaXZ0eGZhemRob2VkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjM3MjY5MDEsImV4cCI6MjAzOTMwMjkwMX0.ypk6eicENjyrdsCm-OLbiiaJAHMfx5gmQQ3XuYBLrys\" \n);\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <SessionContextProvider supabaseClient={supabase}>\n      <App />\n    </SessionContextProvider>\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}