{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["isTerminated","Set","async","fetchWithRetry","url","options","retries","arguments","length","undefined","delay","i","_errorData$error","_errorData$error2","response","fetch","ok","json","errorData","error","status","message","includes","console","warn","Promise","res","setTimeout","refreshAccessToken","log","method","headers","Error","data","access_token","localStorage","setItem","Date","now","expires_in","toString","getValidAccessToken","accessToken","getItem","refreshToken","tokenExpiry","parseInt","body","JSON","stringify","refresh_token","createGoogleCalendarEvent","event","calendarId","session","provider_token","newEvent","summary","title","description","start","dateTime","toISOString","timeZone","end","location","Authorization","id","updateAirtableWithGoogleEventIdAndProcessed","airtableRecordId","googleEventId","hasChanges","calendarLink","updateData","fields","GoogleEventId","Processed","CalendarLink","LastUpdated","fetchUnprocessedEventsFromAirtable","today","setHours","todayISO","split","records","map","record","b","processed","streetAddress","city","state","zipCode","filter","Boolean","join","sleep","ms","resolve","deleteGoogleCalendarEvent","eventId","tokenResponse","removeDuplicateEvents","events","_data$items","items","fetchGoogleCalendarEvents","eventMap","Map","duplicateEvents","forEach","eventKey","toLowerCase","trim","date","has","push","set","App","calendarMap","Savannah","Charleston","Greensboro","MyrtleBeach","Wilmington","Grenville","Columbia","Raleigh","useEffect","checkTokenExpiry","interval","setInterval","clearInterval","supabase","useSupabaseClient","useSession","countdown","setCountdown","useState","nextTenMinuteMark","setMinutes","Math","ceil","getMinutes","max","floor","getTimeUntilNextQuarterHour","calendarEvents","setCalendarEvents","Object","fromEntries","entries","_ref2","calendarName","added","failed","noChange","isEventDifferent","airtableEvent","googleEvent","isTitleDifferent","isStartDifferent","isEndDifferent","isDescriptionDifferent","isLocationDifferent","errorResponse","code","updateGoogleCalendarEvent","_originalEvent$start4","_originalEvent$start5","_originalEvent$end3","_originalEvent$end4","_originalEvent$start6","originalResponse","originalEvent","originalStart","originalEnd","originalTimeZone","normalizeToISO","dateStr","normalizedOriginalStart","normalizedOriginalEnd","normalizedNewStart","normalizedNewEnd","updatedEvent","attempt","statusText","handleLogin","auth","signInWithOAuth","provider","scopes","redirectTo","sessionData","getSession","tokens","token_type","saveTokensToBackend","handleAuthSuccess","fetchAndProcessEvents","updatedCalendarEvents","filteredAirtableEvents","_event$b","replace","googleCalendarEvents","googleEventMap","_event$summary","addedEvents","eventTitle","matchingGoogleEvent","get","calendarError","values","prevEvents","nextSyncTime","currentHour","getHours","timeUntilNextSync","React","createElement","className","seconds","minutes","secs","String","padStart","formatCountdown","onClick","refreshSession","signOut","Fragment","style","display","gridTemplateColumns","gap","_ref3","updated","key","index","eventStart","toLocaleString","eventEnd","isNaN","reportWebVitals","onPerfEntry","Function","then","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","createClient","ReactDOM","createRoot","document","getElementById","render","StrictMode","SessionContextProvider","supabaseClient"],"mappings":"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","file":"static/js/main.c72a34d6.chunk.js","sourcesContent":["\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\n\nimport { useSession, useSupabaseClient} from '@supabase/auth-helpers-react';\nlet isTerminated = false; // Initialize the variable early in the file\nlet processedRecords = new Set(); // Store processed records to prevent duplicates\n\nfunction normalizeDateTime(dateStr) {\n  return new Date(dateStr).toISOString().split(\".\")[0] + \"Z\"; // Removes milliseconds\n}\n\n\nasync function fetchWithRetry(url, options, retries = 3, delay = 10000) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      const response = await fetch(url, options);\n      if (response.ok) return await response.json(); // Return data if successful\n\n      const errorData = await response.json();\n      if (errorData.error?.status === \"PERMISSION_DENIED\" && errorData.error?.message.includes(\"Quota exceeded\")) {\n        console.warn(`Quota exceeded. Retrying in ${delay / 1000} seconds...`);\n        await new Promise(res => setTimeout(res, delay));\n      } else {\n        console.error(\"API request failed:\", errorData);\n        return null;\n      }\n    } catch (error) {\n      console.error(\"Network error during fetch:\", error);\n      await new Promise(res => setTimeout(res, delay));\n    }\n  }\n  console.error(\"Max retries reached. API request failed.\");\n  return null;\n}\n\n\nasync function fetchGoogleCalendarEvents(calendarId) {\n  console.log(`📅 Fetching events for Google Calendar: ${calendarId}`);\n\n  try {\n      let accessToken = await getValidAccessToken();\n      if (!accessToken) {\n          console.error(\"❌ No valid access token available. Attempting to refresh...\");\n          accessToken = await refreshAccessToken();\n      }\n\n      if (!accessToken) {\n          console.error(\"❌ Still no valid access token after refresh. Aborting.\");\n          return;\n      }\n\n      console.log(\"🔑 Using Access Token:\", accessToken);\n\n      const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${new Date().toISOString()}&maxResults=250&orderBy=startTime&singleEvents=true`;\n\n      console.log(`🌍 Calling Google Calendar API: ${url}`);\n\n      const response = await fetch(url, {\n          method: 'GET',\n          headers: { Authorization: `Bearer ${accessToken}` },\n      });\n\n      if (!response.ok) {\n          const errorData = await response.json();\n          console.error('❌ Failed to fetch Google Calendar events:', errorData);\n          return [];\n      }\n\n      const data = await response.json();\n      console.log(`✅ Successfully fetched ${data.items?.length || 0} events.`);\n      return data.items || [];\n\n  } catch (error) {\n      console.error('❌ Error fetching Google Calendar events:', error);\n      return [];\n  }\n}\n\nasync function refreshAccessToken() {\n  try {\n      console.log(\"🔄 Refreshing access token...\");\n\n      const response = await fetch(\"http://localhost:5001/api/refresh-token\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n      });\n\n      if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n      }\n\n      const data = await response.json();\n      if (data.access_token) {\n          console.log(\"✅ New Access Token:\", data.access_token);\n\n          // Store new token & expiry time\n          localStorage.setItem(\"accessToken\", data.access_token);\n          localStorage.setItem(\"tokenExpiry\", (Date.now() + data.expires_in * 1000).toString());\n\n          return data.access_token;\n      } else {\n          throw new Error(\"No access token returned\");\n      }\n  } catch (error) {\n      console.error(\"❌ Failed to refresh token:\", error);\n      return null;\n  }\n}\n\n\nasync function getValidAccessToken() {\n  let accessToken = localStorage.getItem(\"accessToken\");\n  let refreshToken = localStorage.getItem(\"refreshToken\");\n  let tokenExpiry = parseInt(localStorage.getItem(\"tokenExpiry\"), 10) || 0;\n  let now = Date.now();\n\n  if (accessToken && now < tokenExpiry) {\n      console.log(\"✅ Using stored access token.\");\n      return accessToken;\n  }\n\n  if (!refreshToken) {\n      console.error(\"❌ No refresh token available. User must log in.\");\n      return null;\n  }\n\n  console.warn(\"⚠️ Token expired. Refreshing...\");\n\n  try {\n      const response = await fetch(\"https://warrentycalender.vanirinstalledsales.info/api/refresh-token\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ refresh_token: refreshToken }),\n      });\n\n      if (!response.ok) {\n          throw new Error(\"Failed to refresh token\");\n      }\n\n      const data = await response.json();\n      if (!data.access_token) {\n          console.error(\"❌ No new access token received. User must log in again.\");\n          return null;\n      }\n\n      localStorage.setItem(\"accessToken\", data.access_token);\n      localStorage.setItem(\"tokenExpiry\", Date.now() + data.expires_in * 1000);\n      console.log(\"✅ New Access Token:\", data.access_token);\n\n      return data.access_token;\n  } catch (error) {\n      console.error(\"❌ Error refreshing access token:\", error);\n      return null;\n  }\n}\n\n\n\n\n\n\nfunction terminateScript() {\n  isTerminated = true;\n  console.log(\"Terminating all processes.\");\n  clearAllTimers();\n}\n\nif (typeof isTerminated !== 'undefined' && isTerminated) {\n  console.log(\"Script is terminated. Skipping further actions.\");\n}\n\n\nasync function createGoogleCalendarEvent(event, calendarId, session) {\n  if (!session || !session.provider_token) {\n    console.error(\"❌ No valid session token found. Attempting to refresh...\");\n    session = { provider_token: await getValidAccessToken() };\n  }\n\n  if (!session.provider_token) {\n    console.error(\"❌ Still no valid access token after refresh. Aborting event creation.\");\n    return null;\n  }\n\n  console.log(\"🔑 Using Access Token in Script:\", session.provider_token);\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n  \n  const newEvent = {\n    summary: event.title,\n    description: event.description || \"No description provided\",\n    start: { dateTime: new Date(event.start).toISOString(), timeZone: \"America/Toronto\" },\n    end: { dateTime: new Date(event.end).toISOString(), timeZone: \"America/Toronto\" },\n    location: event.location || \"No location provided\",\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${session.provider_token}`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(newEvent),\n    });\n\n    const data = await response.json();\n    \n    if (!response.ok) {\n      console.error(\"❌ Error creating Google Calendar event:\", data);\n      return null;\n    }\n\n    console.log(`✅ Event created successfully: \"${event.title}\" (ID: ${data.id})`);\n    return data.id;\n  } catch (error) {\n    console.error(\"❌ Failed to create event:\", error);\n    return null;\n  }\n}\n\n\n\n// Creates a new Google Calendar event\nasync function createGoogleCalendarEvent3(event, calendarId, session) {\n  console.log(`🔑 Using Access Token: ${session.provider_token}`); // Add this line for debugging\n\n  if (isTerminated) {\n    console.log(\"🛑 Script is terminated. Skipping event creation.\");\n    return null;\n  }\n\n  console.log(`🚀 Checking for duplicate event: \"${event.title}\"`);\n  const duplicateEventId = await checkForDuplicateEvent(event, calendarId, session);\n\n  if (duplicateEventId) {\n    console.log(`⚠️ Skipping creation: Event \"${event.title}\" already exists in Google Calendar.`);\n    return duplicateEventId;\n  }\n\n  console.log(`🚀 Creating new Google Calendar event for: \"${event.title}\"...`);\n\n  // ✅ Ensure proper date formatting\n  const startDate = event.start ? new Date(event.start).toISOString() : null;\n  const endDate = event.end ? new Date(event.end).toISOString() : null;\n\n  if (!startDate || !endDate) {\n    console.error(`❌ Invalid start or end date for event \"${event.title}\":`, { startDate, endDate });\n    return null;\n  }\n\n  // ✅ Ensure location is properly defined\n  const location = [\n    event.streetAddress, \n    event.city, \n    event.state, \n    event.zipCode\n  ].filter(Boolean).join(\", \");\n\n// ✅ Log the extracted location before creating the event\nconsole.log(`📌 Location extracted for event \"${event.title}\":`, location);\nconsole.log(\"🔍 Event Object Before Google Calendar Creation:\", event);\n\n\n  // ✅ Create the event object\n  const newEvent = {\n    summary: event.title,\n    description: event.description || \"No description provided\",\n    start: { dateTime: startDate, timeZone: \"America/Toronto\" },\n    end: { dateTime: endDate, timeZone: \"America/Toronto\" },\n    location: location || \"Unknown Location\", // ✅ Ensures proper location formatting\n};\n\n\n  // ✅ Log event details for debugging\n  console.log(\"📝 Event Details:\");\n  console.log(`- Title: ${event.title}`);\n  console.log(`- Description: ${newEvent.description}`);\n  console.log(`- Start Time: ${startDate}`);\n  console.log(`- End Time: ${endDate}`);\n  console.log(`- Location: ${newEvent.location}`);\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n\n  try {\n    const options = {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${session.provider_token}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(newEvent),\n    };\n    \n    const data = await fetchWithRetry(url, options);\n    \n\n    console.log(`✅ Event created successfully: \"${event.title}\" (ID: ${data.id})`);\n    return data.id;\n  } catch (error) {\n    console.error('❌ Error creating Google Calendar event:', error);\n    return null;\n  }\n}\n\n\n\n\nasync function updateAirtableWithGoogleEventIdAndProcessed(airtableRecordId, googleEventId, hasChanges, calendarLink) {\n  if (!hasChanges) {\n    console.log(`No changes found for record ${airtableRecordId}. Skipping update.`);\n    return; // Exit the function if no changes are found\n  }\n\n  console.log(`Updating Airtable record ${airtableRecordId} with Google Event ID: ${googleEventId}, marking as processed, and adding Calendar Link`);\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  const updateData = {\n    fields: {\n      GoogleEventId: googleEventId,\n      Processed: true, // Mark the record as processed to avoid duplicate syncs\n      CalendarLink: calendarLink, // Add the generated Calendar Link here\n      LastUpdated: new Date().toISOString(),\n    },\n  };\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    const data = await response.json();\n    if (!response.ok) {\n      console.error('Error updating Airtable:', data.error);\n    } else {\n      console.log('Airtable record successfully updated:', data);\n    }\n  } catch (error) {\n    console.error('Error updating Airtable:', error);\n  }\n}\n\nasync function lockAirtableRecord(airtableRecordId) {\n  console.log(`Locking Airtable record ${airtableRecordId}`);\n  \n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  const updateData = { fields: { Processed: true } };\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updateData),\n    });\n\n    const data = await response.json();\n    if (!response.ok) {\n      console.error(`Error locking record ${airtableRecordId}:`, data);\n    } else {\n      console.log(`Record ${airtableRecordId} locked successfully.`);\n    }\n  } catch (error) {\n    console.error(`Error locking record ${airtableRecordId}:`, error);\n  }\n}\n\nasync function unlockAirtableRecord(airtableRecordId) {\n  console.log(`Unlocking Airtable record ${airtableRecordId}`);\n\n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ/${airtableRecordId}`;\n  \n  // Add a delay to ensure Airtable has time to sync before unlocking\n  await sleep(6000); // 3 seconds delay before unlocking\n\n  try {\n    const response = await fetch(url, {\n      method: 'PATCH',\n      headers: {\n        Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ fields: {} }), // Empty body when unlocking\n    });\n\n    const data = await response.json();\n    if (!response.ok) {\n      console.error(`Error unlocking record ${airtableRecordId}:`, data.error || data);\n    } else {\n      console.log(`Record ${airtableRecordId} unlocked successfully.`);\n    }\n  } catch (error) {\n    console.error(`Failed to unlock record ${airtableRecordId}:`, error);\n  }\n}\n\nasync function fetchUnprocessedEventsFromAirtable() {\n  if (isTerminated) {\n    console.log('Script is terminated. Skipping fetch for unprocessed events.');\n    return [];\n  }\n\n  console.log('Fetching unprocessed events from Airtable...');\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  const todayISO = today.toISOString().split(\"T\")[0]; // Extracts YYYY-MM-DD format\n  \n  const url = `https://api.airtable.com/v0/appO21PVRA4Qa087I/tbl6EeKPsNuEvt5yJ?filterByFormula=OR(IS_AFTER({FormattedStartDate}, '${todayISO}'), {FormattedStartDate}='${todayISO}')`;\n  \n  try {\n    const options = {\n      headers: {\n              Authorization: 'Bearer patXTUS9m8os14OO1.6a81b7bc4dd88871072fe71f28b568070cc79035bc988de3d4228d52239c8238',\n              'Content-Type': 'application/json',\n            },\n          };\n          \n          const data = await fetchWithRetry(url, options);\n\n          const records = data.records.map((record) => ({\n            id: record.id,\n            title: record.fields['Lot Number and Community/Neighborhood'] || 'No lot number',\n            start: new Date(record.fields['FormattedStartDate']),\n            end: new Date(record.fields['FormattedEndDate']),\n            description: record.fields['Description of Issue'] || '',\n            b: record.fields['b'] || '',\n            processed: record.fields['Processed'] || false,\n            streetAddress: record.fields['Street Address'] || \"\",\n            city: record.fields['City'] || \"\",\n            state: record.fields['State'] || \"\",\n            zipCode: record.fields['Zip Code'] || \"\",\n            location: [\n                record.fields['Street Address'],\n                record.fields['City'],\n                record.fields['State'],\n                record.fields['Zip Code']\n            ].filter(Boolean).join(', ')\n        }));\n        \n        console.log(\"🚀 Processed Airtable records:\", records);\n        \n        console.log(\"Fetched raw Airtable data:\", data.records);\n\n\n      console.log(\"Fetched unprocessed records:\", records);\n      \n      if (records.length === 0) {\n        console.log('No unprocessed events found.');\n        // Do NOT set isTerminated to true, or reset it after a delay\n        setTimeout(() => { isTerminated = false; }, 60000); // Reset after 1 minute\n      }\n      \n      \n      return records;\n  } catch (error) {\n      console.error('Error fetching Airtable events:', error);\n      return [];\n  }\n}\n\nfunction clearAllTimers() {\n  const highestTimeoutId = setTimeout(() => {}, 0);\n  for (let i = 0; i < highestTimeoutId; i++) {\n    clearTimeout(i);\n  }\n  // Also clear intervals\n  const highestIntervalId = setInterval(() => {}, 0);\n  for (let i = 0; i < highestIntervalId; i++) {\n    clearInterval(i);\n  }\n}\n\n\n// Check for duplicate Google Calendar events\nasync function checkForDuplicateEvent(event, calendarId, session) {\n  console.log(`🔍 Checking for duplicate event: \"${event.title}\"`);\n\n  if (!session || !session.provider_token) {\n      console.warn(\"⚠️ No valid session token found. Fetching a new token...\");\n      session = { provider_token: await getValidAccessToken() };\n      if (!session.provider_token) {\n          console.error(\"❌ Failed to retrieve a valid access token. Skipping duplicate check.\");\n          return null;\n      }\n  }\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events`;\n  const timeMin = event.start ? new Date(event.start).toISOString() : null;\n  const timeMax = event.end ? new Date(event.end).toISOString() : null;\n\n  if (!timeMin || !timeMax) {\n      console.error(`❌ Invalid start or end date for event \"${event.title}\":`, { timeMin, timeMax });\n      return null;\n  }\n\n  try {\n      console.log(`🌍 Fetching events from Google Calendar between ${timeMin} and ${timeMax}...`);\n\n      const response = await fetch(\n          `${url}?timeMin=${encodeURIComponent(timeMin)}&timeMax=${encodeURIComponent(timeMax)}&singleEvents=true`,\n          {\n              headers: {\n                  Authorization: `Bearer ${session.provider_token}`,\n              },\n          }\n      );\n\n      if (!response.ok) {\n          const errorData = await response.json();\n          console.error(\"❌ Failed to fetch events from Google Calendar:\", errorData);\n          return null;\n      }\n\n      const data = await response.json();\n      console.log(`📌 Retrieved ${data.items?.length || 0} events for duplicate check.`);\n\n      if (!data.items || data.items.length === 0) {\n          console.log(`✅ No duplicate event found for \"${event.title}\".`);\n          return null;\n      }\n\n      // Normalize event data for better duplicate detection\n      const normalizeText = (text) => text.trim().replace(/\\s+/g, \" \").toLowerCase();\n      const duplicateEvent = data.items.find((existingEvent) => {\n          if (!existingEvent.start?.dateTime || !existingEvent.end?.dateTime) {\n              console.warn(`⚠️ Skipping event due to missing start or end time:`, existingEvent);\n              return false;\n          }\n\n          const googleStart = normalizeDateTime(existingEvent.start.dateTime);\n          const googleEnd = normalizeDateTime(existingEvent.end.dateTime);\n\n          return (\n              normalizeText(existingEvent.summary) === normalizeText(event.title) &&\n              googleStart === timeMin &&\n              googleEnd === timeMax\n          );\n      });\n\n      if (duplicateEvent) {\n          console.log(`🚨 Duplicate event found: \"${event.title}\", ID: ${duplicateEvent.id}`);\n          return duplicateEvent.id;\n      }\n\n      console.log(`✅ No duplicate event found for: \"${event.title}\".`);\n      return null;\n  } catch (error) {\n      console.error(\"❌ Error checking for duplicate events:\", error);\n      return null;\n  }\n}\n\n\n\n\n\n\n\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nasync function populateGoogleCalendarWithAirtableRecords(\n  calendarId,\n  calendarName,\n  session,\n  setAddedRecords,\n  setFailedRecords,\n  setNoChangeRecords,\n  setAllRecordsProcessed\n) {\n  console.log(`Starting to populate Google Calendar \"${calendarName}\" with Airtable records...`);\n\n  if (isTerminated) {\n    console.log('🛑 Script is terminated. Skipping population.');\n    return;\n  }\n\n  const airtableEvents = await fetchUnprocessedEventsFromAirtable();\n  if (isTerminated) {\n    console.log(\"🛑 Script was terminated after fetching. Stopping processing.\");\n    return;\n  }\n\n  const totalFetchedRecords = airtableEvents.length;\n  if (totalFetchedRecords === 0) {\n    console.log(`✅ No unprocessed events to sync for calendar \"${calendarName}\".`);\n    return;\n  }\n\n  let createdEventsCount = 0;\n  const added = [];\n  const failed = [];\n  const noChange = [];\n  const processedRecordIds = new Set();\n\n  for (const event of airtableEvents) {\n    if (isTerminated) {\n      console.log(\"🛑 Script was terminated. Stopping event processing.\");\n      return;\n    }\n\n    if (event.googleEventId || event.processed) {\n      console.log(`Skipping event \"${event.title}\" - GoogleEventId or Processed status already set.`);\n      noChange.push(event.title);\n      processedRecordIds.add(event.id);\n      continue;\n    }\n\n    try {\n      await lockAirtableRecord(event.id);\n      let googleEventId = await checkForDuplicateEvent(event, calendarId, session);\n\n      if (isTerminated) {\n        console.log(\"🛑 Termination detected. Skipping event creation.\");\n        return;\n      }\n\n      if (googleEventId) {\n        const googleEvent = await getGoogleCalendarEvent(googleEventId, calendarId, session);\n\n        // Skip updates if no changes exist\n        if (!isEventDifferent(event, googleEvent)) {\n          console.log(`✅ No changes detected for event \"${event.title}\". Skipping update.`);\n          noChange.push(event.title);\n          processedRecordIds.add(event.id);\n          await unlockAirtableRecord(event.id);\n          continue;\n        }\n\n        console.log(`⚠️ Updating event \"${event.title}\" as it has changed.`);\n        await updateGoogleCalendarEvent(\n          googleEventId,\n          event.title,\n          event.start,\n          event.end,\n          calendarId,\n          session\n        );\n        await updateAirtableWithGoogleEventIdAndProcessed(event.id, googleEventId, true);\n      } else {\n        console.log(`🆕 Creating new event: ${event.title}`);\n        googleEventId = await createGoogleCalendarEvent(event, calendarId, session);\n        if (googleEventId) {\n          await updateAirtableWithGoogleEventIdAndProcessed(event.id, googleEventId, true);\n          added.push(event.title);\n          createdEventsCount++;\n        } else {\n          failed.push(event.title);\n        }\n      }\n\n      processedRecordIds.add(event.id);\n    } catch (error) {\n      console.error(`❌ Error processing event \"${event.title}\":`, error);\n      failed.push(event.title);\n    }\n\n    await unlockAirtableRecord(event.id);\n    await sleep(12000); // Delay to avoid hitting rate limits\n  }\n\n  if (isTerminated) {\n    console.log(\"🛑 All records processed but script was terminated.\");\n    return;\n  }\n\n  setAddedRecords((prev) => [...prev, ...added]);\n  setFailedRecords((prev) => [...prev, ...failed]);\n  setNoChangeRecords(noChange);\n\n  console.log(`✅ Total number of events created: ${createdEventsCount}`);\n  console.log(`✅ Total number of records processed for calendar \"${calendarName}\": ${processedRecordIds.size}`);\n}\n\nfunction isEventDifferent(airtableEvent, googleEvent) {\n  if (!airtableEvent || !googleEvent || !googleEvent.start || !googleEvent.end) {\n      console.error('❌ Missing event data:', { airtableEvent, googleEvent });\n      return true; \n  }\n\n  const normalizeText = (text) => (text || \"\").trim().toLowerCase();\n  \n  return (\n      normalizeText(airtableEvent.title) !== normalizeText(googleEvent.summary) ||\n      normalizeText(airtableEvent.location) !== normalizeText(googleEvent.location) ||\n      new Date(airtableEvent.start).toISOString() !== googleEvent.start.dateTime ||\n      new Date(airtableEvent.end).toISOString() !== googleEvent.end.dateTime\n  );\n\n}\n\n\n\nasync function updateGoogleCalendarEvent(eventId, title, start, end, calendarId) {\n  console.log(`🔄 Updating event: ${title}`);\n\n  // ✅ Get a fresh valid access token\n  const accessToken = await getValidAccessToken();\n  if (!accessToken) {\n      console.error(\"❌ No valid access token available. Skipping update.\");\n      return;\n  }\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n\n  try {\n      // Fetch the original event details before updating\n      const originalResponse = await fetch(url, {\n          method: 'GET',\n          headers: {\n              Authorization: `Bearer ${accessToken}`,\n              'Content-Type': 'application/json',\n          },\n      });\n\n      if (!originalResponse.ok) {\n          const errorData = await originalResponse.json();\n          console.error('❌ Failed to fetch original Google Calendar event:', errorData);\n          return;\n      }\n\n      const originalEvent = await originalResponse.json();\n      const originalStart = originalEvent.start?.dateTime || originalEvent.start?.date;\n      const originalEnd = originalEvent.end?.dateTime || originalEvent.end?.date;\n      const originalTimeZone = originalEvent.start?.timeZone || \"America/New_York\";\n\n      // Convert to strict ISO format\n      const normalizeToISO = (dateStr) => (dateStr ? new Date(dateStr).toISOString() : null);\n      const normalizedOriginalStart = normalizeToISO(originalStart);\n      const normalizedOriginalEnd = normalizeToISO(originalEnd);\n      const normalizedNewStart = normalizeToISO(start);\n      const normalizedNewEnd = normalizeToISO(end);\n\n      console.log(\"🔵 Original Event Data:\", {\n          title: originalEvent.summary,\n          start: normalizedOriginalStart,\n          end: normalizedOriginalEnd,\n          timeZone: originalTimeZone,\n      });\n\n      console.log(\"🟡 Updated Event Data:\", {\n          summary: title,\n          start: normalizedNewStart,\n          end: normalizedNewEnd,\n          timeZone: originalTimeZone,\n      });\n\n      // ✅ Skip update if nothing has changed\n      if (normalizedNewStart === normalizedOriginalStart && normalizedNewEnd === normalizedOriginalEnd) {\n          console.log(\"✅ No change detected. Skipping update.\");\n          return;\n      }\n\n      console.log(\"⚠️ Changes detected. Updating event...\");\n\n      // Construct updated event object\n      const updatedEvent = {\n          summary: title,\n          start: { dateTime: normalizedNewStart, timeZone: originalTimeZone },\n          end: { dateTime: normalizedNewEnd, timeZone: originalTimeZone },\n      };\n\n      const updateResponse = await fetch(url, {\n          method: 'PUT',\n          headers: {\n              Authorization: `Bearer ${accessToken}`,\n              'Content-Type': 'application/json',\n          },\n          body: JSON.stringify(updatedEvent),\n      });\n\n      if (!updateResponse.ok) {\n          console.error(\"❌ Failed to update event:\", await updateResponse.json());\n          return;\n      }\n\n      console.log(`✅ Event updated successfully: ${title}`);\n  } catch (error) {\n      console.error('❌ Error updating event:', error);\n  }\n}\n\n\n\nasync function getGoogleCalendarEvent(eventId, calendarId, session) {\n  // Fetch the token from the backend\n  const tokenResponse = await fetch('http://localhost:5001/api/tokens');\n  \n  if (!tokenResponse.ok) {\n    console.error(\"Failed to fetch token\");\n    return null;\n  }\n\n  const tokens = await tokenResponse.json();\n  const accessToken = tokens.access_token;\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n  try {\n    const response = await fetch(url, {\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`Failed to fetch event from Google Calendar: ${eventId}`);\n      return null;\n    }\n\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error fetching Google Calendar event:', error);\n    return null;\n  }\n}\n\n\n\nasync function deleteGoogleCalendarEvent(eventId, calendarId, session) {\n  // Fetch the token from the backend\n  const tokenResponse = await fetch('http://localhost:5001/api/tokens');\n  \n  if (!tokenResponse.ok) {\n    console.error(\"Failed to fetch token\");\n    return false;\n  }\n\n  const tokens = await tokenResponse.json();\n  const accessToken = tokens.access_token;\n\n  const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n\n  try {\n    const response = await fetch(url, {\n      method: 'DELETE',\n      headers: {\n        Authorization: `Bearer ${accessToken}`,  // Use the fetched access token\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      const data = await response.json();\n      console.error('Failed to delete Google Calendar event:', data);\n      return false;\n    }\n\n    console.log('Google Calendar event deleted successfully:', eventId);\n    return true;\n  } catch (error) {\n    console.error('Error deleting Google Calendar event:', error);\n    return false;\n  }\n}\n\n\nfunction CalendarSection({\n  calendarId,\n  calendarName,\n  session,\n  signOut,\n  setAddedRecords,\n  setFailedRecords,\n  setNoChangeRecords,\n    triggerSync,\n  setTriggerSync,\n  handleSyncNow,  // Add the handleSyncNow prop here\n  allRecordsProcessed,  // Destructure this prop\n  setAllRecordsProcessed  // Destructure this prop\n}) {\n  const [lastSyncTime, setLastSyncTime] = useState(null);\n  const [progress, setProgress] = useState(0);\n  const [manualSyncComplete, setManualSyncComplete] = useState(false); // Track manual sync completion\n\n  useEffect(() => {\n    const syncEvents = async () => {\n      // Exit if all records are processed\n      if (allRecordsProcessed) {\n        console.log('All records have been processed. Skipping further sync attempts.');\n        terminateScript(); // Terminate the script before returning\n        return;  // Exit the function after terminating\n      }\n  \n \n  \n      console.log('Attempting to sync events...');\n  \n      if (session && triggerSync) {\n        setProgress(0);\n  \n        if (!session.provider_token) {\n          console.error('No valid session token found. Logging out.');\n          signOut();\n          return;\n        }\n  \n        try {\n          // Sync the events with Google Calendar\n          await populateGoogleCalendarWithAirtableRecords(\n            calendarId,\n            calendarName,\n            session,\n            setAddedRecords,\n            setFailedRecords,\n            setNoChangeRecords,\n            setAllRecordsProcessed\n          );\n  \n          console.log(`Finished syncing events to Google Calendar \"${calendarName}\"`);\n  \n          // After syncing, check for duplicates\n          await removeDuplicateEvents();\n  \n          // Set the last sync time and other status updates\n          setLastSyncTime(new Date());\n          setTriggerSync(false);\n          setManualSyncComplete(true);  // Mark manual sync as complete\n  \n        } catch (error) {\n          console.error(`Error syncing Airtable to Google Calendar \"${calendarName}\":`, error);\n        }\n      }\n    };\n  \n    // Only proceed if manual sync is triggered\n    if (triggerSync) {\n      console.log(`Manual sync triggered for calendar: ${calendarName}`);\n      syncEvents(); // Call the async syncEvents function\n    }\n  \n  }, [\n    session, // React hook dependencies\n    signOut,\n    calendarId,\n    calendarName,\n    setAddedRecords,\n    setFailedRecords,\n    setNoChangeRecords,\n    setAllRecordsProcessed,\n    triggerSync, // Trigger sync when this changes\n    setTriggerSync,\n    allRecordsProcessed, // Terminate if all records are processed\n  ]);\n\n  // After syncing Google Calendar\n  useEffect(() => {\n    if (manualSyncComplete) {\n      console.log(\"Manual sync complete. Stopping further checks.\");\n      return; // Terminate further event checks after sync\n    }\n\n    // Continue with other operations if needed\n  }, [manualSyncComplete]); // Dependency on manual sync completion\n\n  return (\n    <div className=\"calendar-item\">\n      <h2>{calendarName}</h2>\n\n      {lastSyncTime && <p>Last sync: {lastSyncTime.toLocaleString()}</p>}\n      {progress > 0 && <p>Sync progress: {progress.toFixed(0)}%</p>}\n  \n    \n  \n  <button onClick={handleSyncNow}>Sync Now</button>\n\n\n{allRecordsProcessed && (\n  <p>All records have been processed. No further syncs are required.</p>\n)}\n    </div>\n  );\n}\n\nasync function removeDuplicateEvents(calendarId, session) {\n  if (isTerminated) {\n    console.log(\"🛑 Script is terminated. Skipping duplicate removal.\");\n    return;\n  }\n\n  console.log(`Checking for duplicate events in calendar: ${calendarId}...`);\n\n  try {\n    const events = await fetchGoogleCalendarEvents(calendarId, session);\n    if (isTerminated) {\n      console.log(\"🛑 Script was terminated after fetching events. Stopping processing.\");\n      return;\n    }\n\n    if (!events || events.length === 0) {\n      console.log(\"No events found in calendar.\");\n      return;\n    }\n\n    const eventMap = new Map();\n    const duplicateEvents = [];\n\n    events.forEach(event => {\n      if (isTerminated) {\n        console.log(\"🛑 Termination detected during duplicate search.\");\n        return;\n      }\n      const eventKey = `${event.summary.toLowerCase().trim()}_${new Date(event.start.dateTime || event.start.date).toISOString()}`;\n\n      if (eventMap.has(eventKey)) {\n        duplicateEvents.push(event);\n      } else {\n        eventMap.set(eventKey, event);\n      }\n    });\n\n    for (const event of duplicateEvents) {\n      if (isTerminated) {\n        console.log(\"🛑 Termination detected. Stopping deletion process.\");\n        return;\n      }\n      await deleteGoogleCalendarEvent(event.id, calendarId, session);\n      console.log(`🗑️ Deleted duplicate event: ${event.summary} (ID: ${event.id})`);\n    }\n  } catch (error) {\n    console.error(`Error removing duplicate events for calendar ID \"${calendarId}\":`, error);\n  }\n}\n\n\n\n\nfunction formatCountdown(seconds) {\n  const minutes = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;\n}\n\nfunction App() {\n  const calendarMap = {\n    Savannah: 'c_ebe1fcbce1be361c641591a6c389d4311df7a97961af0020c889686ae059d20a@group.calendar.google.com',\n    Charleston: 'c_d113e252e0e5c8cfbf17a13149707a30d3c0fbeeff1baaac7a46940c2cc448ca@group.calendar.google.com',\n    Greensboro: 'c_03867438b82e5dfd8d4d3b6096c8eb1c715425fa012054cc95f8dea7ef41c79b@group.calendar.google.com',\n    MyrtleBeach: 'c_ad562073f4db2c47279af5aa40e53fc2641b12ad2497ccd925feb220a0f1abee@group.calendar.google.com',\n    Wilmington: 'c_45db4e963c3363676038697855d7aacfd1075da441f9308e44714768d4a4f8de@group.calendar.google.com',\n   Grenville: 'c_0476130ac741b9c58b404c737a8068a8b1b06ba1de2a84cff08c5d15ced54edf@group.calendar.google.com',\n   Columbia: 'c_df033dd6c81bb3cbb5c6fdfd58dd2931e145e061b8a04ea0c13c79963cb6d515@group.calendar.google.com',\n       Raleigh: 'warranty@vanirinstalledsales.com',\n  };\n\n  // ✅ Automatically refresh token every 55 minutes\nuseEffect(() => {\n  const checkTokenExpiry = async () => {\n      let tokenExpiry = parseInt(localStorage.getItem(\"tokenExpiry\"), 10) || 0;\n      let now = Date.now();\n\n      if (!tokenExpiry || now >= tokenExpiry) {\n          console.warn(\"⚠️ Token expired or missing. Refreshing...\");\n          await getValidAccessToken();\n      } else {\n          console.log(\"✅ Token is still valid.\");\n      }\n  };\n\n  checkTokenExpiry();\n  \n  // Refresh token every 55 minutes (3300 seconds)\n  const interval = setInterval(checkTokenExpiry, 55 * 60 * 1000);\n\n  return () => clearInterval(interval);\n}, []);\n\n\n  function getTimeUntilNextQuarterHour() {\n    const now = new Date();\n    const nextTenMinuteMark = new Date(now);\n    \n    // Calculate the next 10-minute interval from the beginning of the hour\n    nextTenMinuteMark.setMinutes(Math.ceil(now.getMinutes() / 10) * 10, 0, 0);\n\n    // If we're already at the next 10-minute mark, move to the next one\n    if (nextTenMinuteMark <= now) {\n        nextTenMinuteMark.setMinutes(nextTenMinuteMark.getMinutes() + 10);\n    }\n\n    return Math.max(0, Math.floor((nextTenMinuteMark - now) / 1000)); // Return remaining time in seconds\n}\n\n  const supabase = useSupabaseClient();\n  const session = useSession();\n  const [countdown, setCountdown] = useState(getTimeUntilNextQuarterHour());\n  const [calendarEvents, setCalendarEvents] = useState(\n    Object.fromEntries(\n      Object.entries(calendarMap).map(([calendarName]) => [\n        calendarName,\n        { added: [], failed: [], noChange: [] },\n      ])\n    )\n  );\n\n\n\n  function isEventDifferent(airtableEvent, googleEvent) {\n    const isTitleDifferent = airtableEvent.title !== googleEvent.summary;\n    const isStartDifferent = new Date(airtableEvent.start).toISOString() !== googleEvent.start.dateTime;\n    const isEndDifferent = new Date(airtableEvent.end).toISOString() !== googleEvent.end.dateTime;\n    const isDescriptionDifferent = (airtableEvent.description || '') !== (googleEvent.description || '');\n    const isLocationDifferent = (airtableEvent.location || '') !== (googleEvent.location || '');\n  \n    return isTitleDifferent || isStartDifferent || isEndDifferent || isDescriptionDifferent || isLocationDifferent;\n  }\n  \n  \n  async function fetchGoogleCalendarEvents(calendarId) {\n    let accessToken = await getValidAccessToken(); // Get a valid token from storage or refresh\n\n    if (!accessToken) {\n        console.error(\"❌ No valid access token available. Aborting fetch.\");\n        return [];\n    }\n\n    console.log(\"📅 Fetching Google Calendar events with token:\", accessToken);\n\n    try {\n        const response = await fetch(\n            `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events?timeMin=${new Date().toISOString()}&maxResults=250&orderBy=startTime&singleEvents=true`,\n            {\n                method: \"GET\",\n                headers: {\n                    \"Authorization\": `Bearer ${accessToken}`,\n                    \"Content-Type\": \"application/json\",\n                },\n            }\n        );\n\n        if (!response.ok) {\n            const errorResponse = await response.json();\n\n            if (errorResponse.error.code === 401) {\n                console.warn(\"🔄 Access token expired. Attempting to refresh...\");\n\n                // Refresh the token and retry once\n                const newAccessToken = await refreshAccessToken();\n                if (newAccessToken) {\n                    console.log(\"🔄 Retrying event fetch with new token...\");\n                    return await fetchGoogleCalendarEvents(calendarId); // Recursive retry\n                } else {\n                    console.error(\"❌ Failed to refresh token. User may need to re-authenticate.\");\n                    return [];\n                }\n            }\n\n            console.error(\"❌ Google Calendar API Error:\", errorResponse);\n            throw new Error(errorResponse.error.message);\n        }\n\n        const data = await response.json();\n        console.log(`✅ Successfully fetched ${data.items.length} events.`);\n        return data.items || []; // Ensure an empty array is returned if no events exist\n    } catch (error) {\n        console.error(\"❌ Failed to fetch Google Calendar events:\", error.message);\n        return [];\n    }\n}\n\n\n\n  \n  \n\n  \n  \n  \n  \n  async function updateGoogleCalendarEvent(eventId, title, start, end, calendarId) {\n    try {\n        const accessToken = await getValidAccessToken();\n        if (!accessToken) {\n            console.error(\"❌ No valid access token available.\");\n            return;\n        }\n\n        const url = `https://www.googleapis.com/calendar/v3/calendars/${calendarId}/events/${eventId}`;\n\n        // 🟢 Fetch the original event before updating\n        const originalResponse = await fetch(url, {\n            method: 'GET',\n            headers: {\n                Authorization: `Bearer ${accessToken}`,\n                'Content-Type': 'application/json',\n            },\n        });\n\n        if (!originalResponse.ok) {\n            console.error(\"❌ Failed to fetch original Google Calendar event.\");\n            return;\n        }\n\n        const originalEvent = await originalResponse.json();\n        const originalStart = originalEvent.start?.dateTime || originalEvent.start?.date;\n        const originalEnd = originalEvent.end?.dateTime || originalEvent.end?.date;\n        const originalTimeZone = originalEvent.start?.timeZone || \"America/New_York\"; // Default to EST\n\n        // ✅ Normalize all times to strict ISO format\n        const normalizeToISO = (dateStr) => dateStr ? new Date(dateStr).toISOString() : null;\n        const normalizedOriginalStart = normalizeToISO(originalStart);\n        const normalizedOriginalEnd = normalizeToISO(originalEnd);\n        const normalizedNewStart = normalizeToISO(start);\n        const normalizedNewEnd = normalizeToISO(end);\n\n        console.log(\"🔵 Original Event (Before Update):\", {\n            summary: originalEvent.summary,\n            start: normalizedOriginalStart,\n            end: normalizedOriginalEnd,\n            timeZone: originalTimeZone,\n        });\n\n        console.log(\"🟡 Updated Event Data (Before Sending):\", {\n            summary: title,\n            start: normalizedNewStart,\n            end: normalizedNewEnd,\n            timeZone: originalTimeZone,\n        });\n\n        // 🛑 Prevent unnecessary updates if times are unchanged\n        if (normalizedNewStart === normalizedOriginalStart && normalizedNewEnd === normalizedOriginalEnd) {\n            console.log(\"✅ No changes detected. Skipping update.\");\n            return;\n        }\n\n        console.log(\"⚠️ Change detected. Updating event...\");\n\n        // 🔄 Prepare the updated event payload\n        const updatedEvent = {\n            summary: title,\n            start: { dateTime: normalizedNewStart, timeZone: originalTimeZone },\n            end: { dateTime: normalizedNewEnd, timeZone: originalTimeZone },\n        };\n\n        const options = {\n            method: 'PATCH',\n            headers: {\n                Authorization: `Bearer ${accessToken}`,\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(updatedEvent),\n        };\n\n        // ✅ Handle API rate limits by retrying on failure\n        const apiResponse = await fetchWithRetry(url, options);\n        if (!apiResponse) {\n            console.error(\"❌ Failed to update Google Calendar event after retries.\");\n            return;\n        }\n\n        console.log(`✅ Successfully updated event: ${title}`);\n    } catch (error) {\n        console.error(\"❌ Error updating Google Calendar event:\", error);\n    }\n}\nasync function fetchWithRetry(url, options, retries = 3, delay = 2000) {\n  for (let attempt = 1; attempt <= retries; attempt++) {\n      try {\n          const response = await fetch(url, options);\n          if (response.ok) return response;\n\n          console.warn(`⚠️ API call failed (Attempt ${attempt}/${retries}): ${response.statusText}`);\n          if (response.status === 429) {\n              console.log(\"⏳ Rate limit hit. Retrying after delay...\");\n              await new Promise(resolve => setTimeout(resolve, delay));\n          } else {\n              return null; // Stop retrying on other errors\n          }\n      } catch (error) {\n          console.error(\"❌ API request error:\", error);\n      }\n  }\n  return null;\n}\n\n\nuseEffect(() => {\n    const getTimeUntilNextQuarterHour = () => {\n        const now = new Date();\n        const nextSyncTime = new Date(now);\n\n        // Calculate the next 10-minute interval from the beginning of the hour\n        nextSyncTime.setMinutes(Math.ceil(now.getMinutes() / 10) * 10, 0, 0);\n\n        // If we're already at the next 10-minute mark, move to the next one\n        if (nextSyncTime <= now) {\n            nextSyncTime.setMinutes(nextSyncTime.getMinutes() + 10);\n        }\n\n        return Math.max(0, Math.floor((nextSyncTime - now) / 1000)); // Return remaining time in seconds\n    };\n\n    const interval = setInterval(async () => {\n        const currentHour = new Date().getHours();\n        \n        if (currentHour >= 7 && currentHour <= 17) {\n            const timeUntilNextSync = getTimeUntilNextQuarterHour();\n            setCountdown(timeUntilNextSync);\n\n            if (timeUntilNextSync === 0) {\n                console.log(\"⏳ Checking if token needs refresh...\");\n                \n                let accessToken = await getValidAccessToken();\n                if (!accessToken) {\n                    console.error(\"❌ No valid token available. Skipping sync.\");\n                    return;\n                }\n\n                console.log(\"🔄 Running event sync...\");\n                await fetchAndProcessEvents();\n\n                setCountdown(getTimeUntilNextQuarterHour()); // Reset countdown after sync\n            }\n        }\n    }, 1000); // Check every second to determine when to sync\n\n    return () => clearInterval(interval);\n}, [session]); // Depend on session to ensure proper reactivity\n\n  \n\nasync function handleLogin() {\n  try {\n      const { data, error } = await supabase.auth.signInWithOAuth({\n          provider: 'google',\n          options: {\n              scopes: 'https://www.googleapis.com/auth/calendar',\n              redirectTo: \"https://warrentycalender.vanirinstalledsales.info\", // ✅ Explicit redirect\n          },\n      });\n\n      if (error) throw error;\n\n      console.log(\"✅ Supabase Login Started:\", data);\n\n      // ✅ Wait for session update\n      const { data: sessionData } = await supabase.auth.getSession();\n      if (sessionData?.session) {\n          console.log(\"✅ Supabase Session Received:\", sessionData.session);\n          handleAuthSuccess(sessionData.session);\n      } else {\n          console.error(\"❌ Supabase session not found after login.\");\n      }\n  } catch (error) {\n      console.error(\"❌ Error during login:\", error);\n  }\n}\n\n\n\n\nasync function saveTokensToBackend(tokens) {\n  try {\n      const response = await fetch(\"http://localhost:5001/save-tokens\", {\n          method: \"POST\",\n          headers: {\n              \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify(tokens),\n      });\n\n      if (!response.ok) {\n          throw new Error(\"Failed to save tokens\");\n      }\n\n      console.log(\"✅ Tokens successfully sent to the backend.\");\n  } catch (error) {\n      console.error(\"❌ Error saving tokens:\", error);\n  }\n}\n\nasync function handleAuthSuccess(session) {\n  console.log(\"🔑 Tokens received:\", session);\n\n  if (!session?.provider_token) {\n      console.error(\"❌ No access token found.\");\n      return;\n  }\n\n  const tokens = {\n      access_token: session.provider_token,\n      refresh_token: session.refresh_token || localStorage.getItem(\"refreshToken\"), // ✅ Preserve old refresh token if missing\n      expires_in: session.expires_in || 3600,\n      token_type: \"Bearer\",\n  };\n\n  // ✅ Save tokens to backend\n  await saveTokensToBackend(tokens);\n\n  // ✅ Store in LocalStorage\n  localStorage.setItem(\"accessToken\", tokens.access_token);\n  localStorage.setItem(\"refreshToken\", tokens.refresh_token);\n  localStorage.setItem(\"tokenExpiry\", Date.now() + tokens.expires_in * 1000);\n}\n\n\n\n\n\n  \n  const handleLogout = async () => {\n    try {\n      const { error } = await supabase.auth.refreshSession();\n      if (error) {\n        console.error('Error refreshing session:', error);\n      }\n      await supabase.auth.signOut();\n      console.log('User logged out successfully.');\n    } catch (error) {\n      console.error('Error during logout:', error);\n    }\n  };\n  \n\n  async function fetchAndProcessEvents() {\n    try {\n        console.log(\"🚀 Fetching and processing events for all calendars...\");\n\n        // ✅ Retrieve a valid access token ONCE to avoid redundant refreshes\n        let accessToken = await getValidAccessToken();\n        if (!accessToken) {\n            console.error(\"❌ No valid access token available. Aborting.\");\n            return;\n        }\n\n        let allCalendarsProcessed = true;\n        let updatedCalendarEvents = {};\n\n        for (const [calendarName, calendarId] of Object.entries(calendarMap)) {\n            console.log(`📅 Processing events for calendar: ${calendarName}`);\n\n            try {\n                // ✅ Fetch and filter Airtable events for this specific calendar\n                const airtableEvents = await fetchUnprocessedEventsFromAirtable();\n                const filteredAirtableEvents = airtableEvents.filter(\n                    (event) => event.b?.toLowerCase().trim().replace(/\\s+/g, \"\") === calendarName.toLowerCase().trim()\n                );\n\n                if (filteredAirtableEvents.length === 0) {\n                    console.log(`✅ No unprocessed events found for ${calendarName}. Skipping.`);\n                    continue;\n                }\n\n                console.log(`📊 Filtered ${filteredAirtableEvents.length} events from Airtable for calendar: ${calendarName}`);\n                \n                // ✅ Fetch events from Google Calendar (only once per calendar)\n                const googleCalendarEvents = await fetchGoogleCalendarEvents(calendarId);\n                console.log(`📊 Fetched ${googleCalendarEvents.length} events from Google Calendar: ${calendarName}`);\n\n                const googleEventMap = new Map();\n                googleCalendarEvents.forEach((event) => {\n                    googleEventMap.set(event.summary?.toLowerCase().trim(), event);\n                });\n\n                let addedEvents = [];\n\n                for (const airtableEvent of filteredAirtableEvents) {\n                    if (!airtableEvent.start || !airtableEvent.end) {\n                        console.error(`❌ Skipping event \"${airtableEvent.title}\" due to missing start or end date.`);\n                        continue;\n                    }\n\n                    const eventTitle = airtableEvent.title.toLowerCase().trim();\n                    const matchingGoogleEvent = googleEventMap.get(eventTitle);\n\n                    if (matchingGoogleEvent) {\n                        if (isEventDifferent(airtableEvent, matchingGoogleEvent)) {\n                            console.log(`🔄 Updating event: ${airtableEvent.title}`);\n                            await updateGoogleCalendarEvent(\n                                matchingGoogleEvent.id,\n                                airtableEvent.title,\n                                airtableEvent.start,\n                                airtableEvent.end,\n                                calendarId,\n                                accessToken\n                            );\n                        } else {\n                            console.log(`✅ No changes detected for event: ${airtableEvent.title}, skipping update.`);\n                        }\n                    } else {\n                        console.log(`🆕 Creating new event: ${airtableEvent.title}`);\n                        const googleEventId = await createGoogleCalendarEvent(airtableEvent, calendarId, accessToken);\n                        if (googleEventId) {\n                            await updateAirtableWithGoogleEventIdAndProcessed(airtableEvent.id, googleEventId, true);\n                            console.log(`✅ New event created and linked: ${airtableEvent.title}`);\n                            addedEvents.push({\n                                title: airtableEvent.title,\n                                start: airtableEvent.start,\n                                end: airtableEvent.end\n                            });\n                        }\n                    }\n                }\n\n                updatedCalendarEvents[calendarName] = { added: addedEvents };\n\n                console.log(`✅ Finished processing events for calendar: ${calendarName}`);\n                await sleep(5000);\n            } catch (calendarError) {\n                console.error(`❌ Error processing events for calendar \"${calendarName}\":`, calendarError);\n            }\n        }\n\n        // ✅ Remove duplicate events AFTER processing all calendars\n        for (const calendarId of Object.values(calendarMap)) {\n            try {\n                await removeDuplicateEvents(calendarId, accessToken);\n            } catch (error) {\n                console.error(`❌ Error removing duplicate events for calendar ID \"${calendarId}\":`, error);\n            }\n        }\n\n        // ✅ Update state after processing all calendars\n        setCalendarEvents((prevEvents) => ({\n            ...prevEvents,\n            ...updatedCalendarEvents\n        }));\n\n        console.log(\"✅ All events processed for all calendars.\");\n    } catch (error) {\n        console.error(\"❌ Fatal error in fetchAndProcessEvents():\", error);\n    }\n}\n\nreturn (\n  <div className=\"App\">\n    <h1>Google Calendar Sync</h1>\n    \n    <p>Next sync in: {formatCountdown(countdown)}</p>\n    {!session ? (\n  <>\n    <button onClick={fetchAndProcessEvents}>Sync Now</button>\n  </>\n) : (\n  <button onClick={handleLogout}>Logout</button>\n)}\n\n\n\n    {session && (\n      <>\n        <button onClick={fetchAndProcessEvents}>Sync Now</button>\n        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '20px' }}>\n          {Object.entries(calendarEvents).map(([calendarName, events]) => {\n            const added = events?.added || [];\n            const updated = events?.updated || [];\n\n            return (\n              <div key={calendarName} className=\"calendar-section\">\n              <h2>{calendarName}</h2>\n            \n              {added.length > 0 && (\n                <>\n                  <h3>New Events</h3>\n                  <ul>\n                    {added.map((event, index) => {\n                      // Ensure proper date conversion\n                      const eventStart = event.start ? new Date(event.start).toLocaleString() : \"Invalid Date\";\n                      const eventEnd = event.end ? new Date(event.end).toLocaleString() : \"Invalid Date\";\n            \n                      return (\n                        <li key={index}>\n                          <strong>{event.title}</strong> <br />\n                          <span>Start: {isNaN(new Date(event.start)) ? \"Invalid Date\" : eventStart}</span> <br />\n                          <span>End: {isNaN(new Date(event.end)) ? \"Invalid Date\" : eventEnd}</span>\n                        </li>\n                      );\n                    })}\n                  </ul>\n                </>\n              )}\n            \n              {updated.length > 0 && (\n                <>\n                  <h3>Updated Events</h3>\n                  <ul>\n                    {updated.map((event, index) => {\n                      const eventStart = event.start ? new Date(event.start).toLocaleString() : \"Invalid Date\";\n                      const eventEnd = event.end ? new Date(event.end).toLocaleString() : \"Invalid Date\";\n            \n                      return (\n                        <li key={index}>\n                          <strong>{event.title}</strong> <br />\n                          <span>Start: {isNaN(new Date(event.start)) ? \"Invalid Date\" : eventStart}</span> <br />\n                          <span>End: {isNaN(new Date(event.end)) ? \"Invalid Date\" : eventEnd}</span>\n                        </li>\n                      );\n                    })}\n                  </ul>\n                </>\n              )}\n                <button onClick={handleLogin}>Sign in with Google</button>\n\n              {added.length === 0 && updated.length === 0 && <p>No new or updated events.</p>}\n            </div>\n            \n            \n            );\n          })}\n        </div>\n      </>\n    )}\n  </div>\n);\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { createClient } from '@supabase/supabase-js';\nimport { SessionContextProvider } from '@supabase/auth-helpers-react';\n\nconst supabase = createClient(\n  \"https://uesmvtbhivtxfazdhoed.supabase.co\",\n  \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVlc212dGJoaXZ0eGZhemRob2VkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjM3MjY5MDEsImV4cCI6MjAzOTMwMjkwMX0.ypk6eicENjyrdsCm-OLbiiaJAHMfx5gmQQ3XuYBLrys\" \n);\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <SessionContextProvider supabaseClient={supabase}>\n      <App />\n    </SessionContextProvider>\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}